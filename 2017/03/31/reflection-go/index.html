<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="reflecttion," />





  <link rel="alternate" href="/atom.xml" title="悟云" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.jpeg?v=5.1.0" />






<meta name="description" content="反射简介Reflection(反射)在计算机中表示 程序能够检查自身结构的能力，尤其是类型。 它是元编程的一种形式。本文中，我们主要理解Go语言中的的反射运作机制。每个编程语言的反射模型不大相同，很多语言根本不支持反射(C、C++)。笔者在学校主要就是学的C/C++,因此对于反射这个概念不是很清晰，最近接触Go语言，所以从go的角度探索下反射, 下文中谈到“反射”时，默认为时Go语言中的反射。
类">
<meta property="og:type" content="article">
<meta property="og:title" content="Reflection-Go">
<meta property="og:url" content="http://blog.lxmoses.com/2017/03/31/reflection-go/index.html">
<meta property="og:site_name" content="悟云">
<meta property="og:description" content="反射简介Reflection(反射)在计算机中表示 程序能够检查自身结构的能力，尤其是类型。 它是元编程的一种形式。本文中，我们主要理解Go语言中的的反射运作机制。每个编程语言的反射模型不大相同，很多语言根本不支持反射(C、C++)。笔者在学校主要就是学的C/C++,因此对于反射这个概念不是很清晰，最近接触Go语言，所以从go的角度探索下反射, 下文中谈到“反射”时，默认为时Go语言中的反射。
类">
<meta property="og:updated_time" content="2017-03-31T05:33:38.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Reflection-Go">
<meta name="twitter:description" content="反射简介Reflection(反射)在计算机中表示 程序能够检查自身结构的能力，尤其是类型。 它是元编程的一种形式。本文中，我们主要理解Go语言中的的反射运作机制。每个编程语言的反射模型不大相同，很多语言根本不支持反射(C、C++)。笔者在学校主要就是学的C/C++,因此对于反射这个概念不是很清晰，最近接触Go语言，所以从go的角度探索下反射, 下文中谈到“反射”时，默认为时Go语言中的反射。
类">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.lxmoses.com/2017/03/31/reflection-go/"/>





  <title> Reflection-Go | 悟云 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">悟云</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">let it be</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://blog.lxmoses.com/2017/03/31/reflection-go/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="moses">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/me.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="悟云">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="悟云" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Reflection-Go
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-31T11:15:35+08:00">
                2017-03-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index">
                    <span itemprop="name">go</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="反射简介"><a href="#反射简介" class="headerlink" title="反射简介"></a>反射简介</h2><p>Reflection(反射)在计算机中表示 程序能够检查自身结构的能力，尤其是类型。 它是元编程的一种形式。<br>本文中，我们主要理解Go语言中的的反射运作机制。每个编程语言的反射模型不大相同，很多语言根本不支持反射(C、C++)。笔者在学校主要就是学的C/C++,因此对于反射这个概念不是很清晰，最近接触Go语言，所以从go的角度探索下反射, 下文中谈到“反射”时，默认为时Go语言中的反射。</p>
<h2 id="类型和接口"><a href="#类型和接口" class="headerlink" title="类型和接口"></a>类型和接口</h2><p>反射建立在类型系统之上，因此我们从类型基础知识说起。<br>Go是静态语言。每个变量都有且只有一个静态类型，在编译时就已经确定。<br>关于类型，一个重要的分类是接口类型（interface），每个接口类型都代表固定的方法集合。一个接口变量可以指向（接口变量类似于C中的指针）任何类型的具体值，只要这个值实现了该接口类型的所有方法。<br>一个非常非常重要的接口类型是空接口，即:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span>&#123;&#125;	</div></pre></td></tr></table></figure><br>它代表一个空集，没有任何方法。由于任何具体的值都有零个或更多个方法，因此类型为interface{}的变量能够存储任何值。<br>有人说，Go的接口是动态类型的。这个说法是错误的！接口变量也是静态类型的，它永远只有一个相同的静态类型。如果在运行时它存储的值发生了变化，这个必须满足接口类型的方法集合。这是Go的特性。</p>
<h2 id="接口变量的表示"><a href="#接口变量的表示" class="headerlink" title="接口变量的表示"></a>接口变量的表示</h2><p>interface变量存储一对值:赋给改变量的具体的值、值类型的描述符。更确切的说，值就是实现该接口的底层数据，类型就是底层数据类型的描述。举个例子:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> r io.Reader</div><div class="line">tyy, err := os.OpenFile(<span class="string">"/dev/tty"</span>, os.O_RDWR, <span class="number">0</span>)</div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">&#125;</div><div class="line">r = tty</div></pre></td></tr></table></figure><br>在这个例子中，变量r在结构上包含一个(key, value)对:(tty, <em> os.File)。注意：类型os.File不仅仅实现了Read方法。虽然接口变量只提供Read函数的调用权，但是底层的值包含了关于这个值的所有类型消息。所以我们能够做这样的类型转换:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> w io.Writer</div><div class="line">w = r.(io.Writer)</div></pre></td></tr></table></figure><br>上面的第二行代码是一个类型断言，它判定变量r内部的实际值也继承了io.Writer接口，所以才能被赋值给w。赋值之后，w就指向了(tty, </em> os.File）对，和变量r指向的是同一个(value, type)对。<br>不管底层具体值的方法集有多大，由于接口的静态类型限制，接口变量只能调用特定的一些方法。<br>继续看下面的代码:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> empty <span class="keyword">interface</span>&#123;&#125;</div><div class="line">empty = w</div></pre></td></tr></table></figure><br>这里的空接口变量也包含(tty, * os.File)对。这一点很容易理解:空接口变量可以存储任何具体值以及该值的所有描述信息。<br>这里没有使用类型断言,因为w满足空接口的所有方法。另外需要注意的一点是，(value, type)对中的type必须是具体的类型(struct 或 基本类型),不能是接口类型。</p>
<h2 id="反射可以将“接口类型变量”转换为“反射类型”对象"><a href="#反射可以将“接口类型变量”转换为“反射类型”对象" class="headerlink" title="反射可以将“接口类型变量”转换为“反射类型”对象"></a>反射可以将“接口类型变量”转换为“反射类型”对象</h2><p>这里反射类型指reflect.Type和reflect.Value。<br>首先了解下reflect包的两种类型Type和Value。这两种类型使访问接口内的数据成为可能。它们对应两个简单的方法，分别是reflect.TypeOf和reflect.ValueOf,分别是用来读取接口变量的reflect.Type和reflect.Value部分。<br>首先，我们看下reflect.TypeOf:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"reflect"</span></div><div class="line">)</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></div><div class="line">	fmt.Println(<span class="string">"type:"</span>, reflect.TypeOf(x))</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>这行代码会打印出:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span>: <span class="keyword">float64</span></div></pre></td></tr></table></figure><br>为什么没看到接口？ 这段代码看起来只是把一个float64类型的变量x传递给reflect.TypeOf,事实上查阅一下TypeOf的文档:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Type</span></span></div></pre></td></tr></table></figure><br>我们调用reflect.TypeOf(x)时，x被存储在一个空接口变量中被传递过去，然后reflect.TypeOf对空接口变量进行拆解，恢复其类型信息。<br>函数reflect.ValueOf也会对底层的值进行恢复:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></div><div class="line">fmt.Println(<span class="string">"value:"</span>, reflect.ValueOf(x))</div></pre></td></tr></table></figure><br>上面这段代码会打印出:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">value: &lt;<span class="keyword">float64</span> Value&gt;</div></pre></td></tr></table></figure><br>类型 reflect.Type 和 reflect.Value 都有很多方法，我们可以检查和使用它们。这里我们举几个例子。类型 reflect.Value 有一个方法 Type()，它会返回一个 reflect.Type 类型的对象。Type和 Value都有一个名为 Kind 的方法，它会返回一个常量，表示底层数据的类型，常见值有：Uint、Float64、Slice等。Value类型也有一些类似于Int、Float的方法，用来提取底层的数据。Int方法用来提取 int64, Float方法用来提取 float64，参考下面的代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></div><div class="line">v := reflect.ValueOf(x)</div><div class="line">fmt.Println(<span class="string">"type:"</span>, v.Type())</div><div class="line">fmt.Println(<span class="string">"kind is float64:"</span>, v.Kind() == reflect.Float64)</div><div class="line">fmt.Println(<span class="string">"value:"</span>, v.Float())</div></pre></td></tr></table></figure><br>上面这段代码会打印出:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span>: <span class="keyword">float64</span></div><div class="line">kind is <span class="keyword">float64</span>: <span class="literal">true</span></div><div class="line">value: <span class="number">3.4</span></div></pre></td></tr></table></figure><br>反射库提供了很多值得列出来单独讨论的属性。首先是介绍下Value 的 getter 和 setter 方法。为了保证API 的精简，这两个方法操作的是某一组类型范围最大的那个。比如，处理任何含符号整型数，都使用 int64。也就是说 Value 类型的Int 方法返回值为 int64类型，SetInt 方法接收的参数类型也是 int64 类型。实际使用时，可能需要转化为实际的类型。<br>第二个属性是反射类型变量（reflection object）的 Kind 方法 会返回底层数据的类型，而不是静态类型。如果一个反射类型对象包含一个用户定义的整型数,看代码:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></div><div class="line"><span class="keyword">var</span> x MyInt = <span class="number">7</span></div><div class="line">v := relect.ValueOf(x)</div></pre></td></tr></table></figure><br>上面的代码中，虽然变量 v 的静态类型是MyInt，不是 int，Kind 方法仍然返回 reflect.Int。换句话说， Kind 方法不会像 Type 方法一样区分 MyInt 和 int。</p>
<h2 id="反射可以将“反射类型对象”转换为“接口类型变量”"><a href="#反射可以将“反射类型对象”转换为“接口类型变量”" class="headerlink" title="反射可以将“反射类型对象”转换为“接口类型变量”"></a>反射可以将“反射类型对象”转换为“接口类型变量”</h2><p>根据一个 reflect.Value 类型的变量，我们可以使用 Interface 方法恢复其接口类型的值。事实上，这个方法会把 type 和 value 信息打包并填充到一个接口变量中，然后返回。其函数声明如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Interface returns v's value as an interface&#123;&#125;.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Interface</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125;</div></pre></td></tr></table></figure><br>然后我们可以通过断言，恢复底层的具体值:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">y := v.Interface().(<span class="keyword">float64</span>)</div><div class="line">fmt.Println(y)</div></pre></td></tr></table></figure><br>事实上，我们可以更好地利用这一特性。标准库中的 fmt.Println 和 fmt.Printf 等函数都接收空接口变量作为参数，fmt 包内部会对接口变量进行拆包（前面的例子中，我们也做过类似的操作）。因此，fmt 包的打印函数在打印 reflect.Value 类型变量的数据时，只需要把 Interface 方法的结果传给 格式化打印程序:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fmt.Println(v.Interface())</div></pre></td></tr></table></figure></p>
<h2 id="如果要修改“反射类型对象”，其值必须是“可写的”-settable"><a href="#如果要修改“反射类型对象”，其值必须是“可写的”-settable" class="headerlink" title="如果要修改“反射类型对象”，其值必须是“可写的”(settable)"></a>如果要修改“反射类型对象”，其值必须是“可写的”(settable)</h2><p>“可写性”有些类似于寻址能力，但是更严格。它是反射类型变量的一种属性，赋予该变量修改底层存储数据的能力。“可写性”最终是由一个事实决定的：反射对象是否存储了原始值。举个代码例子：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></div><div class="line">v := reflect.ValueOf(x)</div><div class="line">v.SetFLoat(<span class="number">7.1</span>)</div></pre></td></tr></table></figure><br>如果这行代码能够成功执行，它不会更新 x ，虽然看起来变量 v 是根据 x 创建的。相反，它会更新 x 存在于 反射对象 v 内部的一个拷贝，而变量 x 本身完全不受影响。这会造成迷惑，并且没有任何意义，所以是不合法的。“可写性”就是为了避免这个问题而设计的。<br>上面的代码中，我们把变量 x 的一个拷贝传递给函数，因此不期望它会改变 x 的值。如果期望函数 f 能够修改变量 x，我们必须传递 x 的地址（即指向 x 的指针）给函数 f，如下:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">f(&amp;x)</div></pre></td></tr></table></figure><br>反射的工作机制是一样的。如果你想通过反射修改变量x，就要把想要修改的变量的指针传递给反射库。<br>首先，像通常一样初始化变量x，然后创建一个指向它的反射对象，名字为p:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></div><div class="line">p := reflect.ValueOf(&amp;x)</div><div class="line">fmt.Println(<span class="string">"type of p:"</span>, p.Type())</div><div class="line">fmt.Println(<span class="string">"settability of p:"</span>, p.CanSet())</div></pre></td></tr></table></figure><br>这段代码的输出是:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> of p: * <span class="keyword">float64</span></div><div class="line">settability of p: <span class="literal">false</span></div></pre></td></tr></table></figure><br>反射对象p是不可写的，但是我们也无意修改p，事实上我们要修改的是 * p。为了得到p指向的数据，可以调用Value类型的Elem方法。Elem方法能够对指针进行“解引用”,然后将结果存储到Value类型对象v中:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">v := p.Elem()</div><div class="line">fmt.Printlen(<span class="string">"settability of v:"</span>, v.CanSet())</div></pre></td></tr></table></figure><br>上面这段代码的输出:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">settability of v: <span class="literal">true</span></div></pre></td></tr></table></figure><br>由于变量v代表x，因此我们可以使用v.SetFloat修改x的值:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">v.SetFloat(<span class="number">7.1</span>)</div><div class="line">fmt.Println(v.Interface())</div><div class="line">fmt.Println(x)</div></pre></td></tr></table></figure><br>上面的代码输出如下:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">7.1</span></div><div class="line"><span class="number">7.1</span></div></pre></td></tr></table></figure><br>反射不太容易理解，reflect.Type 和 reflect.Value 会混淆正在执行的程序，但是它做的事情正是编程语言做的事情。记住：只要反射对象要修改它们表示的对象，就必须获取它们表示的对象的地址。</p>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>把反射应用到结构体时，常用的方式是 使用反射修改一个结构体的某些字段。只要拥有结构体的地址，我们就可以修改它的字段。<br>下面是一个简单的例子:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</div><div class="line">	A <span class="keyword">int</span></div><div class="line">	B <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line">t := T&#123;<span class="number">23</span>, <span class="string">"skidoo"</span>&#125;</div><div class="line">s := reflect.ValueOf(&amp;t).Elem()</div><div class="line">	typeOfT := s.Type()</div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; s.NumField(); i++ &#123;</div><div class="line">		f := s.Field(i)</div><div class="line">		fmt.Printf(<span class="string">"%d: %s %s = %v\n"</span>, i,</div><div class="line">			typeOfT.Field(i).Name, f.Type(), f.Interface())</div><div class="line">	&#125;</div></pre></td></tr></table></figure><br>上面这段代码的输出如下:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>: A <span class="keyword">int</span> = <span class="number">23</span></div><div class="line"><span class="number">1</span>: B <span class="keyword">string</span> = skidoo</div></pre></td></tr></table></figure><br>这里有一点需要指出:变量 T 的字段都是首字母大写的（暴露到外部），因为struct中只有暴露到外部的字段才是“可写的”。<br>由于变量 s 包含一个“可写的”反射对象，我们可以修改结构体的字段:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">s.Field(<span class="number">0</span>).SetInt(<span class="number">77</span>)</div><div class="line">s.Field(<span class="number">1</span>).SetString(<span class="string">"Sunset Strip"</span>)</div><div class="line">fmt.Println(<span class="string">"t is now"</span>, t)</div></pre></td></tr></table></figure><br>上面的代码输出如下:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">t is now &#123;<span class="number">77</span> Sunset Strip&#125;</div></pre></td></tr></table></figure><br>如果变量s是通过t，而不是&amp;t创建的，调用SetInt和SetString将会失败，因为t的字段是不可写的。<br>顺便一提，struct中的tag可以通过反射获得:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tag := s.Field(<span class="number">0</span>).Tag.Get(<span class="string">"testtag"</span>)</div></pre></td></tr></table></figure></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/reflecttion/" rel="tag"># reflecttion</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/03/22/goroutine/" rel="next" title="Goroutine & Channel">
                <i class="fa fa-chevron-left"></i> Goroutine & Channel
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/03/31/c-闭包探索/" rel="prev" title="C++闭包探索">
                C++闭包探索 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/me.jpeg"
               alt="moses" />
          <p class="site-author-name" itemprop="name">moses</p>
          <p class="site-description motion-element" itemprop="description">你我都是彼此的过客</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">54</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">41</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="http://github.com/StephenWuyun" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://tianshuang.me" title="Poison" target="_blank">Poison</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://yunfan.me" title="Yunfan" target="_blank">Yunfan</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.bestrenhao.com" title="Tyson" target="_blank">Tyson</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.wenrui.me" title="WenRui" target="_blank">WenRui</a>
                </li>
              
            </ul>
          </div>
        
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="https://music.daoapp.io/iframe?song=167727&qssl=1&qlrc=0&qnarrow=0&autoplay=1"></iframe>


        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#反射简介"><span class="nav-number">1.</span> <span class="nav-text">反射简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类型和接口"><span class="nav-number">2.</span> <span class="nav-text">类型和接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接口变量的表示"><span class="nav-number">3.</span> <span class="nav-text">接口变量的表示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#反射可以将“接口类型变量”转换为“反射类型”对象"><span class="nav-number">4.</span> <span class="nav-text">反射可以将“接口类型变量”转换为“反射类型”对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#反射可以将“反射类型对象”转换为“接口类型变量”"><span class="nav-number">5.</span> <span class="nav-text">反射可以将“反射类型对象”转换为“接口类型变量”</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如果要修改“反射类型对象”，其值必须是“可写的”-settable"><span class="nav-number">6.</span> <span class="nav-text">如果要修改“反射类型对象”，其值必须是“可写的”(settable)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结构体"><span class="nav-number">7.</span> <span class="nav-text">结构体</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">moses</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	




  
  

  

  

  

  


</body>
</html>
