<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>悟云</title>
  <subtitle>let it be</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.lxmoses.com/"/>
  <updated>2017-01-06T05:12:04.000Z</updated>
  <id>http://blog.lxmoses.com/</id>
  
  <author>
    <name>moses</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>UDP（用户数据报协议）</title>
    <link href="http://blog.lxmoses.com/2017/01/06/UDP%EF%BC%88%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE%EF%BC%89/"/>
    <id>http://blog.lxmoses.com/2017/01/06/UDP（用户数据报协议）/</id>
    <published>2017-01-06T03:01:30.000Z</published>
    <updated>2017-01-06T05:12:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>UDP是一个简单地面向数据报的传输层协议：进程的每个输出操作正好产生一个UDP数据报，并组装成一份待发送的IP数据报。这与面向流字符的协议不同，如TCP,应用程序产生的全体数据与真正发送的单个IP数据报可能没有什么联系。<br>UDP数据报封装成一份IP数据报，如下图所示。<br><img src="/images/UDP封装.jpg" alt=""><br>UDP不提供可靠性：它把应用程序传给IP层的数据发送出去，但是并不保证它们能到达目的地。</p>
<h2 id="UDP首部"><a href="#UDP首部" class="headerlink" title="UDP首部"></a>UDP首部</h2><p>UDP首部的各字段如下图所示。<br><img src="/images/UDP首部.png" alt=""><br>端口号表示发送进程和接收进程。<br>UDP长度字段指的是UDP首部和UDP数据的字节长度。该字段的最小值为8字节（发送一份0字节的UDP数据报是ok的）。<br>UDP校验和，UDP和TCP在首部中都有覆盖它们首部和数据的检验和。UDP的检验和是可选的，而TCP的检验和是必需的。UDP的数据报的长度可以为奇数字节，但是检验和算法是把若干个16bit字相加。解决方法是必要时在最后增加填充字节0，这只是为了检验和的计算（也就是说，可能增加的填充字节不被传送）。其次，UDP数据报和TCP段都包括一个12字节长的伪首部，它是为了计算检验和而设置的。UDP校验和是一个端到端的校验和。它由发送端计算，然后由接收端验证。其目的是为了发现UDP首部和数据在发送端到接收端之间发生的任何改动。不要完全相信数据链路（如以太网，令牌环等）的CRC检验，应该始终打开端到端的检验和功能。而且如果你的数据很有价值，也不要挖暖相信UDP和TCP的校验和，因为这些都是简单地检验和，不能检测出所有可能发生的差错。</p>
<h2 id="UDP服务器的设计"><a href="#UDP服务器的设计" class="headerlink" title="UDP服务器的设计"></a>UDP服务器的设计</h2><h3 id="客户IP地址及端口号"><a href="#客户IP地址及端口号" class="headerlink" title="客户IP地址及端口号"></a>客户IP地址及端口号</h3><p>来自客户的事UDP数据报。IP首部包含源端和目的端IP地址，UDP首部包含了源端和目的端的UDP端口号。<br>这个特性允许一个交互UDP服务器对多个客户进行处理。给每个发送请求的客户端发回应答。</p>
<h3 id="目的IP地址"><a href="#目的IP地址" class="headerlink" title="目的IP地址"></a>目的IP地址</h3><p>一些应用程序需要知道数据报是发送给谁的，这要求操作系统从接收到的UDP数据报中将目的IP地址交给应用程序。不幸的是，并所有的操作系统都提供这个功能。</p>
<h3 id="UDP输入队列"><a href="#UDP输入队列" class="headerlink" title="UDP输入队列"></a>UDP输入队列</h3><p>通常程序所使用的每个UDP端口都与一个有限大小的输入队列相联系。这意味着，来自不同客户的差不多同时到达的请求将由UDP自动排队。接收到的UDP数据报以其接收顺序交给应用程序（在应用程序要求交送下一个数据报时）。然而，排队溢出造成内核中的UDP模块丢弃数据报的可能性是存在的。</p>
<h3 id="限制本地IP地址"><a href="#限制本地IP地址" class="headerlink" title="限制本地IP地址"></a>限制本地IP地址</h3><p>大多数UDP服务器在创建UDP端点时都使其本地IP地址具有通配符（wildcard）的特点。这就表明进入的UDP数据报如果其目的地为服务器端口，那么在任何本地接口均可接受到它。<br>当服务器创建端点时，它可以把其中一个主机本地IP地址包括广播地址指定为端点的本地IP地址。只有当目的IP地址与指定的地址相匹配时，进入的UDP数据报才能被送达这个端点。<br>有可能在相同的端口上启动不同的服务器，每个服务器具有不同的本地IP地址。但是，一般必须告诉系统应用程序重用相同的端口是没问题的。使用socket API时，必须指定SO_REUSEADDR选项。</p>
<h3 id="限制远端IP地址"><a href="#限制远端IP地址" class="headerlink" title="限制远端IP地址"></a>限制远端IP地址</h3><p>大多数系统允许UDP端点对远端地址进行限制。这说明端点将只能接收特定IP地址和端口号的UDP数据报。</p>
<h3 id="每个端口有多个接收者"><a href="#每个端口有多个接收者" class="headerlink" title="每个端口有多个接收者"></a>每个端口有多个接收者</h3><p>大多数的系统在某一时刻只允许一个程序端点与某个本地IP地址及UDP端口号关联。<br>在一个支持多播的系统上，这种情况将发生变化。多个端点可以使用同一个IP地址和UDP端口号，尽管应用程序通常必须告诉API是可行的。使用socket API时，必须指定SO_REUSEADDR选项。当UDP数据报到达目的IP地址为多播地址或广播地址，而且目的IP地址和端口号处有多个端点时，就向每个端点传送一份数据报的复制。但是如果UDP数据报到达的是一个单播地址，那么只向其中一个端点传送一份数据报的复制。选择哪个端点传送数据取决于各个不同的系统实现。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;UDP是一个简单地面向数据报的传输层协议：进程的每个输出操作正好产生一个UDP数据报，并组装成一份待发送的IP数据报。这与面向流字符的协议不
    
    </summary>
    
      <category term="TCP/IP详解" scheme="http://blog.lxmoses.com/categories/TCP-IP%E8%AF%A6%E8%A7%A3/"/>
    
    
      <category term="网络编程" scheme="http://blog.lxmoses.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="UDP" scheme="http://blog.lxmoses.com/tags/UDP/"/>
    
  </entry>
  
  <entry>
    <title>在终端里查看外网Ip的方法</title>
    <link href="http://blog.lxmoses.com/2017/01/05/%E5%9C%A8%E7%BB%88%E7%AB%AF%E9%87%8C%E6%9F%A5%E7%9C%8B%E5%A4%96%E7%BD%91ip%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://blog.lxmoses.com/2017/01/05/在终端里查看外网ip的方法/</id>
    <published>2017-01-05T04:36:29.000Z</published>
    <updated>2017-01-05T04:37:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>转自<a href="https://segmentfault.com/a/1190000000302955" target="_blank" rel="external">这里</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自&lt;a href=&quot;https://segmentfault.com/a/1190000000302955&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;

    
    </summary>
    
      <category term="计算机基础" scheme="http://blog.lxmoses.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="IP" scheme="http://blog.lxmoses.com/tags/IP/"/>
    
  </entry>
  
  <entry>
    <title>IP:网际协议</title>
    <link href="http://blog.lxmoses.com/2017/01/04/IP-%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE/"/>
    <id>http://blog.lxmoses.com/2017/01/04/IP-网际协议/</id>
    <published>2017-01-04T14:26:36.000Z</published>
    <updated>2017-01-05T05:42:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>IP是TCP/IP协议族中最为核心的协议。所有的TCP、UDP、ICMP、及IGMP数据都以IP数据报格式传输。<br>IP提供不可靠、无连接的数据报传送服务。<br>不可靠的意思是它不能保证IP数据报能成功到达目的地。任何要求的可靠性必须由上层来提供（如TCP）。<br>无连接这个术语的意思是IP并不维护任何关于后续数据报的状态信息。如果一信源向相同的信宿发送两个连续的数据报（先是A，然后是B），每个数据报都是独立地进行路由选择，可能选择不同的路线，因此B可能在A之前先到达。</p>
<h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>互联网上的每个接口必须有一个唯一的Internet地址（IP地址）。IP地址具有一定的结构，五类不同的IP地址格式如下图所示。<br><img src="/images/五种不同格式的互联网地址.png" alt=""><br>有三类IP地址：单播地址（目的端为单个主机）、广播地址（目的端为给定网络上的所有主机）以及多播地址（目的端为同一组内的所有主机）</p>
<h2 id="IP首部"><a href="#IP首部" class="headerlink" title="IP首部"></a>IP首部</h2><p><img src="/images/IP数据报格式及首部中的各字段.jpg" alt=""><br>IP数据包的格式如上图所示, 普通的IP首部长为20个字节，除非含有选项字段。分析上图的首部，最高位在左边，记为0bit，最低位在右边，记为31bit。这种传输次序称作big endian字节序，由于TCP、IP首部中的所有二进制整数在网络中传输时都要求以这种次序，因此又称为网络字节序。以其他形式存储二进制整数的机器，例如little endian格式，则必须在传输数据之前把首部转换成网络字节序。<br>目前最常用的协议版本号是4，因此IP有时也称作IPV4.<br>首部长度指的是首部占32bit字的数目，包括任何选项。<br>服务类型（TOS)字段包括一个3bit的优先权字段（现在已被忽略），4bit的TOS字段和1bit未用但必须置为0.4bit的TOS分别代表：最小时延、最大吞吐量、最高可靠性和最小费用。<br>总长度字段是指整个IP数据报的长度，以字节为单位。由于该字段长16比特，所以IP数据报最长可达65535字节。<br>标识字段唯一地标识主机发送的每一份数据报。<br>TTL（time to live）生存时间字段设置了数据报可以经过的最多路由数器数。它指定了数据报的生存时间。TTL的初始值由源主机设置（通常为32或64），一旦经过一个处理它的路由器，它的值就减1。当该字段的值为0时，数据包就被丢弃，并发送ICMP报文通知源主机。<br>协议字段是一个长度为8bit的数值。1表示ICMP协议，2表示IGMP协议，6表示TCP协议，17表示UDP协议。<br>首部检验和字段是根据IP首部计算的校验码。具体可参见<a href="https://blog.lxmoses.com/2017/01/04/ip首部检验和/">这里</a><br>每一份IP数据报都包含源IP地址和目的IP地址。<br>最后一个是任选项，是数据报中的一个可变长的可选信息。</p>
<h2 id="IP路由选择"><a href="#IP路由选择" class="headerlink" title="IP路由选择"></a>IP路由选择</h2><p>此部分比较复杂，在以后的博文中会进行详细研究。</p>
<h2 id="子网寻址"><a href="#子网寻址" class="headerlink" title="子网寻址"></a>子网寻址</h2><p>现在所有的主机都要求支持子网编址。不是把IP地址看成单纯由单纯的一个网络号和一个主机号组成，而是把主机号再分成一个子网号和一个主机号。<br>这么做的原因是因为A类和B类地址为主机号分配了太多的空间，可分别容纳的主机数量为2的24次方-2和2的2的16次方-2（由于全0或全1的主机号是无效的，因此我们把总数-2）.事实上，在一个网络中人们并不安排这么多的主机。<br>从InterNIC获得某类IP网络号后，就由当地的系统管理员来进行分配，有他决定来决定是否建立子网，以及分配多少比特给子网号和主机号。<br>子网对外部路由器来说隐藏了内部网络阻止（一个校园或公司内部）的细节。<br>与30个C类地址，用一个包含30个子网的B类地址的好处是，它可以缩小Internet路由表的规模。</p>
<h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><p>子网掩码是一个32bit的值，其中值为1的比特留个网络号和子网号，为0的比特留给主机号。<br>尽管IP地址一般以点分十进制表示，但是子网掩码却经常用十六进制来表示。<br>给定子网掩码后，主机就可以确定IP数据报的目的是：<br>（1）本子网上的主机<br>（2）本网络中的其他主机<br>（3）其他网络上的主机</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;IP是TCP/IP协议族中最为核心的协议。所有的TCP、UDP、ICMP、及IGMP数据都以IP数据报格式传输。&lt;br&gt;IP提供不可靠、无连
    
    </summary>
    
      <category term="TCP/IP协议详解" scheme="http://blog.lxmoses.com/categories/TCP-IP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"/>
    
    
      <category term="网络编程" scheme="http://blog.lxmoses.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>IP首部检验和</title>
    <link href="http://blog.lxmoses.com/2017/01/04/ip%E9%A6%96%E9%83%A8%E6%A3%80%E9%AA%8C%E5%92%8C/"/>
    <id>http://blog.lxmoses.com/2017/01/04/ip首部检验和/</id>
    <published>2017-01-04T13:40:48.000Z</published>
    <updated>2017-01-04T14:28:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>在发送数据时，为了计算数IP据报的校验和。应该按如下步骤：<br>（1）把IP数据报的首部都置为0，包括校验和字段。<br>（2）把首部看成以16位为单位的数字组成，依次进行二进制反码求和。<br>（3）把得到的结果存入校验和字段中。<br>在接收数据时，计算数据报的校验和相对简单，按如下步骤：<br>（1）把首部看成以16位为单位的数字组成，依次进行二进制反码求和，包括校验和字段。<br>（2）检查计算出的校验和的结果是否等于零。<br>（3）如果等于零，说明被整除，校验是和正确。否则，校验和就是错误的，协议栈要抛弃这个数据包。<br>下面是校验代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="title">checksum</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> *buf,<span class="keyword">int</span> nword)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> sum;</div><div class="line"></div><div class="line">	<span class="keyword">for</span>(sum=<span class="number">0</span>;nword&gt;<span class="number">0</span>;nword--)&#123;</div><div class="line">		sum += *buf++;</div><div class="line">		sum = (sum&gt;&gt;<span class="number">16</span>) + (sum&amp;<span class="number">0xffff</span>);<span class="comment">//相加后最高位如果有进位，加到低位。</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> ~sum;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> iph[]=&#123;<span class="number">0x4500</span>,<span class="number">0x00ad</span>,<span class="number">0x7755</span>,<span class="number">0x4000</span>,<span class="number">0x8006</span>,</div><div class="line">		<span class="number">0x0000</span>,<span class="number">0x0a97</span>,<span class="number">0x7819</span>,<span class="number">0x0a97</span>,<span class="number">0x781d</span>&#125;;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> cksum;</div><div class="line"></div><div class="line">	cksum=checksum(iph,<span class="number">20</span>);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%X\n"</span>,cksum);</div><div class="line">	iph[<span class="number">5</span>]=cksum;</div><div class="line">	cksum=checksum(iph,<span class="number">20</span>);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%X\n"</span>,cksum);</div><div class="line">	<span class="keyword">if</span>(cksum)</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"Checksum is incorrect!\n"</span>);</div><div class="line">	<span class="keyword">else</span></div><div class="line">		<span class="built_in">printf</span>(<span class="string">"Checksum is correct!\n"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>上面的算法应该包含一些数理规律，对此笔者懒得追究了。。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在发送数据时，为了计算数IP据报的校验和。应该按如下步骤：&lt;br&gt;（1）把IP数据报的首部都置为0，包括校验和字段。&lt;br&gt;（2）把首部看成以16位为单位的数字组成，依次进行二进制反码求和。&lt;br&gt;（3）把得到的结果存入校验和字段中。&lt;br&gt;在接收数据时，计算数据报的校验和
    
    </summary>
    
      <category term="TCP/IP协议详解" scheme="http://blog.lxmoses.com/categories/TCP-IP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"/>
    
    
      <category term="网络编程" scheme="http://blog.lxmoses.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>计算机数的表示和存储</title>
    <link href="http://blog.lxmoses.com/2017/01/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E6%95%B0%E7%9A%84%E5%AD%98%E5%82%A8/"/>
    <id>http://blog.lxmoses.com/2017/01/04/计算机中数的存储/</id>
    <published>2017-01-04T12:33:30.000Z</published>
    <updated>2017-01-04T12:42:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>转自<a href="http://www.cnblogs.com/lyfruit/archive/2013/04/07/3003376.html" target="_blank" rel="external">这里</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自&lt;a href=&quot;http://www.cnblogs.com/lyfruit/archive/2013/04/07/3003376.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;

    
    </summary>
    
      <category term="计算机基础" scheme="http://blog.lxmoses.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="编码" scheme="http://blog.lxmoses.com/tags/%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP四层协议系统概述</title>
    <link href="http://blog.lxmoses.com/2017/01/04/TCP-IP%E5%9B%9B%E5%B1%82%E5%8D%8F%E8%AE%AE%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
    <id>http://blog.lxmoses.com/2017/01/04/TCP-IP四层协议系统概述/</id>
    <published>2017-01-04T02:10:50.000Z</published>
    <updated>2017-01-04T13:43:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/tcp-ip协议族的四个层次.jpg" alt=""><br>链路层，有时称为数据链路层或网络接口层，通常包括操作系统中的设备驱动程序和计算机中对应的网络接口卡。它们一起处理与电缆（或其他任何传输媒介）的物理接口细节。<br>网络层，有时也称为互联网层，处理分组在网络中的活动，例如分组的选路。在tcp/ip协议族中，网络层协议包括ip协议（网际协议），icmp协议（internet互联网控制报文协议）以及IGMP协议（internet组管理协议）。<br>运输层，主要为两台主机上的应用程序提供端到端的通信。<br>应用层，负责处理特定的应用程序细节。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/tcp-ip协议族的四个层次.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;链路层，有时称为数据链路层或网络接口层，通常包括操作系统中的设备驱动程序和计算机中对应的网络接口卡。它们一起处理与电缆（或其他任何传输媒介）的物理接口细节。&lt;br&gt;网络层，有时
    
    </summary>
    
      <category term="TCP/IP协议详解" scheme="http://blog.lxmoses.com/categories/TCP-IP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"/>
    
    
      <category term="网络编程" scheme="http://blog.lxmoses.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>最近的几次面试</title>
    <link href="http://blog.lxmoses.com/2017/01/03/%E9%9D%A2%E8%AF%95/"/>
    <id>http://blog.lxmoses.com/2017/01/03/面试/</id>
    <published>2017-01-03T14:13:02.000Z</published>
    <updated>2017-01-03T12:33:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>自从从老汤那里辞职回学校以后，放松了一段时间，然后又开始投简历。经历了几次面试。<br>由于快毕业了， 所以找工作的区域不再局限于成都，全国海投！<br>第一次笔试是北京一家叫做光合起源的公司hr通过qq给笔者发了一份面试题，挺简单的，都是一些基础知识。hr反馈说看笔者测试题做得不错，问我什么时候有空去北京去面试，笔者暂时走不开，就此搁置。<br>接下来是2016年12月一天之内的三次面试。<br>上午电话面试。上海一家游戏公司， 面试官主要问了一些算法的东西，无奈笔者对算法没有深入的探究，面试官简单地问了几句也觉得无趣，然后草草结束面试。<br>下午环球中心，启明星辰一面，首先让笔者做了一套面试题，内容大概是一些简单的编程知识以及linux常用命令。除了网络方面的东西都还应对的可以，第二天一面顺利通过。<br>然后匆匆赶去蜀都中心， 萤火虫游戏， 去这家公司的路途中感觉很熟悉，到了地方发现巧了， 大概半年前面过隔壁的游戏公司，当时拿到了offer但是hr说第一个月没工资，迫于生计，拒绝了。<br>言归正传， 到了公司以后还是做了一套面试题。 感觉这家公司面试题逼格比较高，笔者留下了一张照片。<br><img src="/images/萤火虫面试题.jpg" alt=""><br>智力题除了第四题，其他简单地想了下还是答上来了。 编程题比较偏算法，关于最短路径以及求点到直线的距离的算法不是很熟悉，没能写出来，只是简单地表述了下我的思路。<br>关于面试题第四题，笔者简单搜索了下，发现是自己高估了这道题的难度，主要是前面的都是类似脑筋急转弯之内的东西，突然来了个正常不习惯！！！下面是答案:<br>一个罐子：1个红球。另一个罐子：49个红球，50个篮球<br>笔试完了之后由于面试官开会，等了半个小时， 果然不出所料， 面试官问我acm， 无奈笔者acm只是水水地参与了一下，实在难登大雅之堂。面试官转问我tcp的细节，笔者比较偏向实用主义，对于网络编程，也是停留在读完unp卷一的水准， 面试官鄙视地说：“我很好奇你这两年干的啥啊”。 笔者无言以对。只是下定决心回来好好学习下常用的算法并且立马买了tcp/ip详解。<br>今天早上清晨吸着霾挤着地铁公交去启明星辰二面。 由于面试官开会， 等了一个小时。 面试官是成都分部技术方面的老大，这次面试对我触动挺大的。<br>笔者也经历了七八次面试吧，之前的面试官主要问的都是一些基础知识，但这次面试官主要问我项目经历。 笔者面试时精神属于高度集中的那种，而且潜意识里认为面试内容应该不会详细到业务这种程度，一时没领会到他要我详细描述项目这个意思，导致面试官有些不耐烦， 交流不是很顺畅。（最怕空气突然安静） 由于我没有及时细谈项目，面试官一度怀疑我根本是在编造项目经验！！！ 后来我重新详细地描述了下之前的项目经历， 然后面试官叫我重新发份简历到他的邮箱然后结合一面的面试官再决定是否给我三面的机会。<br>其实这些面试对我来说倒是不那么在意结果，毕竟类似这样的公司遍地都是。然而在这个过程中暴露了很多笔者自身的问题。<br>第一，笔者面试时心态不够平和，精神过度集中，导致表现出的思维不够灵活，表达能力偏弱。 以后的每一次面试都要以一副云淡风轻的态度淡然面对，虽然我是打工的，但人格层面并不比谁第一等，也没必要表现地那么卑微。<br>第二，现在的面试官经常会问一些常用的算法，这是笔者的短板，其实说来这些算法也不是多难，简单地准备一周应该能应对大部分面试官。 虽然在下认为其实工作中这些并没有什么卵用，但是这个社会就是这样，求职的人多了，面试官就会通过这些光环来刷人，笔者无力改变，只能接受。<br>第三，笔者为人处世的态度比较随意，与面试时高度紧张的态度相反，面试之前通常是毫无准备，简历也是比较随意， 以后需要多加注意。应该以一个成年人的态度来面对社会了。<br>谈不上优秀,也算不上渣。 人潮中，我是那么的普通。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自从从老汤那里辞职回学校以后，放松了一段时间，然后又开始投简历。经历了几次面试。&lt;br&gt;由于快毕业了， 所以找工作的区域不再局限于成都，全国海投！&lt;br&gt;第一次笔试是北京一家叫做光合起源的公司hr通过qq给笔者发了一份面试题，挺简单的，都是一些基础知识。hr反馈说看笔者测试
    
    </summary>
    
      <category term="随笔" scheme="http://blog.lxmoses.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="面试" scheme="http://blog.lxmoses.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>C++的四种类型转换方式</title>
    <link href="http://blog.lxmoses.com/2016/12/29/c++%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%96%B9%E5%BC%8F/"/>
    <id>http://blog.lxmoses.com/2016/12/29/c++的四种类型转换方式/</id>
    <published>2016-12-28T22:40:23.000Z</published>
    <updated>2016-12-28T23:02:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>c++的四种强制类型转换，所以c++不是类型安全的。分别为：static_cast , dynamic_cast , const_cast , reinterpret_cast<br>使用C风格的强制转换可以把想要的任何东西转换成合乎心意的类型，那为什么还需要一个新的C++类型的强制转换呢？<br>新类型的强制转换可以提供更好的控制强制转换过程，允许控制各种不同种类的强制转换。C++中风格是static_cast<type>(content)。C++风格的强制转换其他的好处是，它们能更清晰的表明它们要干什么。程序员只要扫一眼这样的代码，就能立即知道一个强制转换的目的。</type></p>
<h2 id="四种类型转换的区别"><a href="#四种类型转换的区别" class="headerlink" title="四种类型转换的区别"></a>四种类型转换的区别</h2><h3 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h3><p>实现C++中内置基本数据类型之间的相互转换<br><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> c=<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">7.987</span>);</div></pre></td></tr></table></figure></p>
<h3 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h3><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> SA &#123;</div><div class="line">	<span class="keyword">int</span> i;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">const</span> SA ra;</div><div class="line"><span class="comment">//ra.i = 10; //直接修改const类型，编译错误</span></div><div class="line">SA &amp;rb = <span class="keyword">const_cast</span>&lt;SA&amp;&gt;(ra);</div><div class="line">rb.i =<span class="number">10</span>;</div></pre></td></tr></table></figure>
<h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">（1）其他三种都是编译时完成的，dynamic_cast是运行时处理的，运行时要进行类型检查。</div><div class="line">（2）不能用于内置的基本数据类型的强制转换。</div><div class="line">（3）dynamic_cast转换如果成功的话返回的是指向类的指针或引用，转换失败的话则会返回NULL。</div><div class="line">（4）使用dynamic_cast进行转换的，基类中一定要有虚函数，否则编译不通过。</div><div class="line">（5）在类的转换时，在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的。在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。向上转换即为指向子类对象的转化为指向父类对象。向下转换，即将父类指针转化子类指针。向下转换的成功与否还与将要转换的类型有关，即要转换的指针指向的对象的实际类型与转换以后的对象类型一定要相同，否则转换失败。</div></pre></td></tr></table></figure>
<h3 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">有着和C风格的强制转换同样的能力。它可以转化任何内置的数据类型为其他任何的数据类型，也可以转化任何指针类型为其他的类型。它甚至可以转化内置的数据类型为指针，无须考虑类型安全或者常量的情形。不到万不得已绝对不用。</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;c++的四种强制类型转换，所以c++不是类型安全的。分别为：static_cast , dynamic_cast , const_cast 
    
    </summary>
    
      <category term="c++" scheme="http://blog.lxmoses.com/categories/c/"/>
    
    
      <category term="类型转换" scheme="http://blog.lxmoses.com/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>C++临时对象</title>
    <link href="http://blog.lxmoses.com/2016/12/29/c++%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1/"/>
    <id>http://blog.lxmoses.com/2016/12/29/c++临时对象/</id>
    <published>2016-12-28T22:20:51.000Z</published>
    <updated>2016-12-28T22:31:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>考虑以下代码:<br><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="built_in">string</span> <span class="title">foo</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">"temp"</span>);&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(<span class="built_in">string</span> &amp;s)</span></span>&#123;&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="comment">/*bar(foo());*/</span></div><div class="line">	bar(<span class="string">"temp"</span>);</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"success"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>上面的代码会引发错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">conference.cpp:15:2: error: no matching function for call to &apos;bar&apos; bar(&quot;temp&quot;);</div></pre></td></tr></table></figure><br>原因在于foo()和“temp”都会产生一个临时对象，而在c++中，这些临时对象都是const类型的。因此上面的程序就是试图将一个const类型的对象转换为非const类型，这是非法的。<br>因此，在确定函数内部不会改变参数时，尽量将引用定义为常引用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;考虑以下代码:&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;figcaption&gt;&lt;span&gt;++&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/di
    
    </summary>
    
      <category term="c++" scheme="http://blog.lxmoses.com/categories/c/"/>
    
    
      <category term="临时对象" scheme="http://blog.lxmoses.com/tags/%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>C语言字节对齐</title>
    <link href="http://blog.lxmoses.com/2016/12/28/c%E8%AF%AD%E8%A8%80%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/"/>
    <id>http://blog.lxmoses.com/2016/12/28/c语言字节对齐/</id>
    <published>2016-12-28T02:37:57.000Z</published>
    <updated>2016-12-28T03:28:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是字节对齐"><a href="#什么是字节对齐" class="headerlink" title="什么是字节对齐"></a>什么是字节对齐</h2><p>现代计算机中，内存空间按照字节划分，理论上可以从任何起始地址访问任意类型的变量。但实际中在访问特定类型变量时经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序一个接一个地存放，这就是对齐。<br>字节对齐的问题主要就是针对结构体。</p>
<h2 id="对其准则"><a href="#对其准则" class="headerlink" title="对其准则"></a>对其准则</h2><h3 id="四个重要的基本概念："><a href="#四个重要的基本概念：" class="headerlink" title="四个重要的基本概念："></a>四个重要的基本概念：</h3><p>1) 数据类型自身的对齐值：char型数据自身对齐值为1字节，short型数据为2字节，int/float型为4字节，double型为8字节。<br>2) 结构体或类的自身对齐值：其成员中自身对齐值最大的那个值。<br>3) 指定对齐值：#pragma pack (value)时的指定对齐值value。<br>4) 数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中较小者，即有效对齐值=min{自身对齐值，当前指定的pack值}。<br>基于上面这些值，就可以方便地讨论具体数据结构的成员和其自身的对齐方式。<br>其中，有效对齐值N是最终用来决定数据存放地址方式的值。有效对齐N表示“对齐在N上”，即该数据的“存放起始地址%N=0”。而数据结构中的数据变量都是按定义的先后顺序存放。第一个数据变量的起始地址就是数据结构的起始地址。结构体的成员变量要对齐存放，结构体本身也要根据自身的有效对齐值圆整(即结构体成员变量占用总长度为结构体有效对齐值的整数倍)。</p>
<h3 id="三个准则："><a href="#三个准则：" class="headerlink" title="三个准则："></a>三个准则：</h3><p>1) 结构体变量的首地址能够被其最宽基本类型成员的大小所整除；<br>2) 结构体每个成员相对结构体首地址的偏移量(offset)都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节(internal adding)；<br>3) 结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节{trailing padding}。<br>对于以上规则的说明如下：<br>第一条：编译器在给结构体开辟空间时，首先找到结构体中最宽的基本数据类型，然后寻找内存地址能被该基本数据类型所整除的位置，作为结构体的首地址(我们自己计算结构体变量大小时，假想首地址为0即可)。将这个最宽的基本数据类型的大小作为上面介绍的对齐模数。<br>第二条：为结构体的一个成员开辟空间之前，编译器首先检查预开辟空间的首地址相对于结构体首地址的偏移是否是本成员大小的整数倍，若是，则存放本成员，反之，则在本成员和上一个成员之间填充一定的字节，以达到整数倍的要求，也就是将预开辟空间的首地址后移几个字节。<br>第三条：结构体总大小是包括填充字节，最后一个成员满足上面两条以外，还必须满足第三条，否则就必须在最后填充几个字节以达到本条要求。</p>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* OFFSET宏定义可取得指定结构体某成员在结构体内部的偏移 */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> OFFSET(st, field)     (size_t)&amp;(((st*)0)-&gt;field)</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</div><div class="line">	<span class="keyword">char</span>  a;</div><div class="line">	<span class="keyword">short</span> b;</div><div class="line">	<span class="keyword">char</span>  c;</div><div class="line">	<span class="keyword">int</span>   d;</div><div class="line">	<span class="keyword">char</span>  e[<span class="number">3</span>];</div><div class="line">&#125;T_Test;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;  </div><div class="line">	<span class="built_in">printf</span>(<span class="string">"Size = %d\n  a-%d, b-%d, c-%d, d-%d\n  e[0]-%d, e[1]-%d, e[2]-%d\n"</span>,</div><div class="line">		<span class="keyword">sizeof</span>(T_Test), OFFSET(T_Test, a), OFFSET(T_Test, b),</div><div class="line">		OFFSET(T_Test, c), OFFSET(T_Test, d), OFFSET(T_Test, e[<span class="number">0</span>]),</div><div class="line">		OFFSET(T_Test, e[<span class="number">1</span>]),OFFSET(T_Test, e[<span class="number">2</span>]));</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行后输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Size = 16</div><div class="line">a-0, b-2, c-4, d-8</div><div class="line">e[0]-12, e[1]-13, e[2]-14</div></pre></td></tr></table></figure><br>下面来具体分析：<br>首先char a占用1个字节，没问题。<br>short b本身占用2个字节，根据上面准则2，需要在b和a之间填充1个字节。<br>char c占用1个字节，没问题。<br>int d本身占用4个字节，根据准则2，需要在d和c之间填充3个字节。<br>char e[3]；本身占用3个字节，根据原则3，需要在其后补充1个字节。<br>因此，sizeof(T_Test) = 1 + 1 + 2 + 1 + 3 + 4 + 3 + 1 = 16字节。</p>
<h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><p>1)将自对齐字节大的变量放在前面，可以使结构体变量占用空间尽可能小.<br>2)使用伪指令#pragma pack(n)：C编译器将按照n个字节对齐；使用伪指令#pragma pack()： 取消自定义字节对齐方式。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是字节对齐&quot;&gt;&lt;a href=&quot;#什么是字节对齐&quot; class=&quot;headerlink&quot; title=&quot;什么是字节对齐&quot;&gt;&lt;/a&gt;什么是字节对齐&lt;/h2&gt;&lt;p&gt;现代计算机中，内存空间按照字节划分，理论上可以从任何起始地址访问任意类型的变量。但实际中在访问特定类
    
    </summary>
    
      <category term="C" scheme="http://blog.lxmoses.com/categories/C/"/>
    
    
      <category term="字节对齐" scheme="http://blog.lxmoses.com/tags/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/"/>
    
  </entry>
  
  <entry>
    <title>From Now On</title>
    <link href="http://blog.lxmoses.com/2016/12/21/from-now-on/"/>
    <id>http://blog.lxmoses.com/2016/12/21/from-now-on/</id>
    <published>2016-12-21T10:50:36.000Z</published>
    <updated>2016-12-21T10:55:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>2014年的冬天， 经常吃泡面，作息混乱，心情抑郁，开始长痘。<br>笔者是个不修边幅的屌丝， 虽然照镜子挺别扭的， 但是一直也没采取什么措施，仍旧是经常熬夜，吃辣的。<br>从现在开始，再不吃辣的，不熬夜。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2014年的冬天， 经常吃泡面，作息混乱，心情抑郁，开始长痘。&lt;br&gt;笔者是个不修边幅的屌丝， 虽然照镜子挺别扭的， 但是一直也没采取什么措施，仍旧是经常熬夜，吃辣的。&lt;br&gt;从现在开始，再不吃辣的，不熬夜。&lt;/p&gt;

    
    </summary>
    
      <category term="随笔" scheme="http://blog.lxmoses.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://blog.lxmoses.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Epoll深入了解</title>
    <link href="http://blog.lxmoses.com/2016/12/20/epoll%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/"/>
    <id>http://blog.lxmoses.com/2016/12/20/epoll深入了解/</id>
    <published>2016-12-20T01:48:09.000Z</published>
    <updated>2016-12-20T01:54:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="epoll相对select的优势"><a href="#epoll相对select的优势" class="headerlink" title="epoll相对select的优势"></a>epoll相对select的优势</h2><p>1.select的句柄数目受限，在linux/posix_types.h头文件有这样的声明：#define __FD_SETSIZE    1024  表示select最多同时监听1024个fd。而epoll没有，它的限制是最大的打开文件句柄数目。<br>2.epoll的最大好处是不会随着FD的数目增长而降低效率，在selec中采用轮询处理，其中的数据结构类似一个数组的数据结构，而epoll是维护一个队列，直接看队列是不是空就可以了。epoll只会对”活跃”的socket进行操作—这是因为在内核实现中epoll是根据每个fd上面的callback函数实现的。那么，只有”活跃”的socket才会主动的去调用 callback函数（把这个句柄加入队列），其他idle状态句柄则不会，在这点上，epoll实现了一个”伪”AIO。但是如果绝大部分的I/O都是“活跃的”，每个I/O端口使用率很高的话，epoll效率不一定比select高（可能是要维护队列复杂）。<br>3.使用mmap加速内核与用户空间的消息传递。无论是select,poll还是epoll都需要内核把FD消息通知给用户空间，如何避免不必要的内存拷贝就很重要，在这点上，epoll是通过内核于用户空间mmap同一块内存实现的</p>
<h2 id="epool中et和lt的区别与实现原理"><a href="#epool中et和lt的区别与实现原理" class="headerlink" title="epool中et和lt的区别与实现原理"></a>epool中et和lt的区别与实现原理</h2><p>LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你 的，所以，这种模式编程出错误可能性要小一点。传统的select/poll都是这种模型的代表．<br>ET (edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述 符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致 了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once),不过在TCP协议中，ET模式的加速效用仍需要更多的benchmark确认。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;epoll相对select的优势&quot;&gt;&lt;a href=&quot;#epoll相对select的优势&quot; class=&quot;headerlink&quot; title=&quot;epoll相对select的优势&quot;&gt;&lt;/a&gt;epoll相对select的优势&lt;/h2&gt;&lt;p&gt;1.select的句柄数目受
    
    </summary>
    
      <category term="网络编程" scheme="http://blog.lxmoses.com/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="epoll" scheme="http://blog.lxmoses.com/tags/epoll/"/>
    
  </entry>
  
  <entry>
    <title>TCP的流量控制和拥塞控制</title>
    <link href="http://blog.lxmoses.com/2016/12/20/TCP%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%92%8C%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/"/>
    <id>http://blog.lxmoses.com/2016/12/20/TCP的流量控制和拥塞控制/</id>
    <published>2016-12-20T00:19:12.000Z</published>
    <updated>2016-12-20T01:33:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h2><p>TCP的流量控制是通过滑动窗口实现的。</p>
<h3 id="什么是滑动窗口协议"><a href="#什么是滑动窗口协议" class="headerlink" title="什么是滑动窗口协议"></a>什么是滑动窗口协议</h3><p>一图胜千言，看下面的图。简单解释下，发送和接受方都会维护一个数据帧的序列，这个序列被称作窗口。发送方的窗口大小由接受方确定，目的在于控制发送速度，以免接受方的缓存不够大，而导致<br>溢出，同时控制流量也可以避免网络拥塞。下面图中的4,5,6号数据帧已经被发送出去，但是未收到关联的ACK，7,8,9帧则是等待发送。可以看出发送端的窗口大小为6，这是由接受端告知的（事实上必<br>须考虑拥塞窗口cwnd，这里暂且考虑cwnd&gt;rwnd）。此时如果发送端收到4号ACK，则窗口的左边缘向右收缩，窗口的右边缘则向右扩展，此时窗口就向前“滑动了”，即数据帧10也可以被发送。<br><img src="/images/滑动窗口.jpg" alt=""><br>下面就滑动窗口协议做出更详细的说明，这里为了简单起见设定发送方窗口大小为2，接受方大小为1。看下面图：<br><img src="/images/滑动窗口过程.gif" alt=""><br>一：初始态，发送方没有帧发出，发送窗口前后沿相重合。接收方0号窗口打开，等待接收0号帧；<br>二：发送方打开0号窗口，表示已发出0帧但尚确认返回信息。 此时接收窗口状态不变；<br>三：发送方打开0、1号窗口，表示0、1号帧均在等待确认之列。至此，发送方打开的窗口数已达规定限度，在未收到新的确认返回帧之 前，发送方将暂停发送新的数据帧。接收窗口此时状态仍未变；<br>四：接收方已收到0号帧，0号窗口关闭，1号窗口打开，表示准备接收1号帧。此时发送窗口状态不 变；<br>五：发送方收到接收方发来的0号帧确认返回信息，关闭0号窗口，表示从重发表中删除0号帧。此时接收窗口状态仍不变<br>六：发送方继续发送2号帧，2号窗口 打开，表示2号帧也纳入待确认之列。至此，发送方打开的窗口又已达规定限度，在未收到新的确认返回帧之前，发送方将暂停发送新的数据帧，此时接收窗口状态 仍不变；<br>七：接收方已收到1号帧，1号窗口关闭，2号窗口打开，表示准备接收2号帧。此时发送窗口状态不变；<br>八：发送方收到接收方发来的1号帧收毕的确认信 息，关闭1号窗口，表示从重发表中删除1号帧。此时接收窗口状态仍不变。</p>
<h3 id="1比特滑动窗口协议"><a href="#1比特滑动窗口协议" class="headerlink" title="1比特滑动窗口协议"></a>1比特滑动窗口协议</h3><p>上面说的只是滑动窗口协议的理论，实际应用中又有不同。<br>首先就是停等协议(stop－and－wait)，这时接受方的窗口和发送方的窗口大小都是1，1个比特就够表示了，所以也叫1比特滑动窗口协议。<br>发送方这时自然发送每次只能发送一个，并且必须等待这个数据包的ACK，才能发送下一个。虽然在效率上比较低，带宽利用率明显较低，不过在网络环境较差，或是带宽本身很低的情况下，还是适用的。</p>
<h3 id="后退n协议"><a href="#后退n协议" class="headerlink" title="后退n协议"></a>后退n协议</h3><p>停等协议虽然实现简单，也能较好的适用恶劣的网络环境，但是显然效率太低。所以有了后退n协议，这也是滑动窗口协议真正的用处，这里发送的窗口大小为n，接受方的窗口仍然为1。具体看下面的图，这里假设n=9：<br>首先发送方一口气发送10个数据帧，前面两个帧正确返回了，数据帧2出现了错误，这时发送方被迫重新发送2-8这7个帧，接受方也必须丢弃之前接受的3-8这几个帧。<br>后退n协议的好处无疑是提高了效率，但是一旦网络情况糟糕，则会导致大量数据重发，反而不如上面的停等协议，实际上这是很常见的，具体可以参考TCP拥塞控制。<br><img src="/images/后退n步滑动窗口.gif" alt=""></p>
<h3 id="选择重传协议"><a href="#选择重传协议" class="headerlink" title="选择重传协议"></a>选择重传协议</h3><p>后退n协议的另外一个问题是，当有错误帧出现后，总是要重发该帧之后的所有帧，毫无疑问在网络不是很好的情况下会进一步恶化网络状况，重传协议便是用来解决这个问题。<br>原理也很简单，接收端总会缓存所有收到的帧，当某个帧出现错误时，只会要求重传这一个帧，只有当某个序号后的所有帧都正确收到后，才会一起提交给高层应用。重传协议的缺点在于接受端需要更多的缓存。</p>
<h2 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h2><p>计算机网络中的带宽、交换节点中的缓存和处理机等，都是网络的资源，在某段时间内，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏，这种情况就叫做拥塞。<br>所谓拥塞控制，就是防止过多的数据注入到网络中，从而使网络中的路由器或链路不致过载。<br>要注意用拥塞控制与流量控制的区别，拥塞控制是一个全局性的过程，涉及到所有的额主机、路由器，以及与降低网<br>拥塞控制的算法有：慢开始、拥塞避免、快重传、快恢复四种。</p>
<h3 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h3><p>发送方维持一个拥塞窗口的状态变量，其大小取决于网络的拥塞程度，动态地变化，而发送窗口一般取拥塞窗口和对方给出的接收窗口的最小值（为了便于描述，后面的分析中假定对方给出的接收窗口足够大，这样将发送窗口等于拥塞窗口就可以了）。<br>慢开始算法的核心是从小到大逐渐增大发送窗口，也就是说，从小到大逐渐增大拥塞窗口的数值。通常在刚开始发送报文段时，先把拥塞窗口设置为一个最大报文段MSS的数值，而在每收到对上一轮报文段（，每次加倍后的报文段的个数，可能不止一个报文段）的确认后，就把拥塞窗口的数值加倍。<br>为了防止拥塞窗口增长过大引起网络拥塞，还需要维护一个慢开始门限的状态变量，当拥塞窗口的值小于慢开始门限时，使用慢开始算法，一旦拥塞窗口的值大于慢开始门限的值，就改用拥塞避免算法。<br>拥塞避免算法的思路是让拥塞窗口缓慢地增大，收到每一轮的确认后，将拥塞窗口的值加1，而不是加倍，这样拥塞窗口的值按照线性规律缓慢增长。<br>无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（没有按时收到确认），就把慢开始门限设置为出现拥塞时发送窗口值的一半，但最小不能小于2个MSS值，而后把拥塞窗口的值重新设置为1个MSS，执行慢开始算法。</p>
<h3 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h3><p>快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（重复发送对前面有序部分的确认），而不是等待自己发送数据时才进行稍待确认，也不是累积收到的报文发送累积确认，如果发送方连续收到三个重复确认，就应该立即重传对方未收到的报文段（有收到重复确认，说明后面的报文段都送达了，只有中间丢失的报文段没送达）。<br>快恢复算法与快重传算法配合使用，其过程有如下两个要点：<br>1、当发送方连续收到三个重复确认时，就把慢开始门限减半，这是为了预防网络发生拥塞。注意，接下来不执行慢开始算法。<br>2、由于发送方现在认为网络很很可能没有发生特别严重的阻塞（如果发生了严重阻塞的话，就不会一连有好几个报文段到达接收方，就不会导致接收方连续发送重复确认），因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口的值不设为1个MSSS），而是把拥塞窗口的值设为慢开始门限减半后的值，而后开始执行拥塞避免算法，线性地增大拥塞窗口。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;TCP的流量控制&quot;&gt;&lt;a href=&quot;#TCP的流量控制&quot; class=&quot;headerlink&quot; title=&quot;TCP的流量控制&quot;&gt;&lt;/a&gt;TCP的流量控制&lt;/h2&gt;&lt;p&gt;TCP的流量控制是通过滑动窗口实现的。&lt;/p&gt;
&lt;h3 id=&quot;什么是滑动窗口协议&quot;&gt;&lt;a 
    
    </summary>
    
      <category term="网络编程" scheme="http://blog.lxmoses.com/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="TCP" scheme="http://blog.lxmoses.com/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>闹够了</title>
    <link href="http://blog.lxmoses.com/2016/12/16/%E9%97%B9%E5%A4%9F%E4%BA%86/"/>
    <id>http://blog.lxmoses.com/2016/12/16/闹够了/</id>
    <published>2016-12-16T15:41:24.000Z</published>
    <updated>2016-12-16T15:44:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>你的城市没有一扇窗，为我打开啊。<br>我要卖掉我的房子，浪迹天涯。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你的城市没有一扇窗，为我打开啊。&lt;br&gt;我要卖掉我的房子，浪迹天涯。&lt;/p&gt;

    
    </summary>
    
      <category term="随笔" scheme="http://blog.lxmoses.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="生活" scheme="http://blog.lxmoses.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>关于C语言main函数执行前后</title>
    <link href="http://blog.lxmoses.com/2016/12/16/%E5%85%B3%E4%BA%8Ec%E8%AF%AD%E8%A8%80main%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E5%89%8D%E5%90%8E/"/>
    <id>http://blog.lxmoses.com/2016/12/16/关于c语言main函数执行前后/</id>
    <published>2016-12-16T06:07:52.000Z</published>
    <updated>2016-12-16T06:24:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前几次的面试经历中好几次面试官都问过程序运行时在main函数之前发生了些什么。 笔者大概知道是做一些初始化相关的事情，今日详细mark一下。<br>main函数执行之前，主要就是初始化系统相关资源：<br>1.设置栈指针<br>2.初始化static静态和global全局变量，即data段的内容<br>3.将未初始化部分的赋初值：数值型short，int，long等为0，bool为FALSE，指针为NULL，等等，即.bss段的内容<br>4.运行全局构造器，估计是C++中构造函数之类的吧<br>5.将main函数的参数，argc，argv等传递给main函数，然后才真正运行main函数<br>同样地，main函数结束之后就是一些资源释放的事情,以及调用之前注册的终止处理程序等等。<br>附上一段apue上注册终止程序的demo:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_exit1</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_exit2</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(atexit(my_exit2) != <span class="number">0</span>)&#123;</div><div class="line">		err_sys(<span class="string">"can't register my_exit2"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span>(atexit(my_exit1) != <span class="number">0</span>)&#123;</div><div class="line">		err_sys(<span class="string">"can't register my_exit1"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span>(atexit(my_exit1) != <span class="number">0</span>)&#123;</div><div class="line">		err_sys(<span class="string">"can't register my_exit1"</span>);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"main is done\n"</span>);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_exit1</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"first exit handler\n"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_exit2</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"second exit handler\n"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前几次的面试经历中好几次面试官都问过程序运行时在main函数之前发生了些什么。 笔者大概知道是做一些初始化相关的事情，今日详细mark一下。&lt;br&gt;main函数执行之前，主要就是初始化系统相关资源：&lt;br&gt;1.设置栈指针&lt;br&gt;2.初始化static静态和global全局
    
    </summary>
    
      <category term="重温apue" scheme="http://blog.lxmoses.com/categories/%E9%87%8D%E6%B8%A9apue/"/>
    
    
      <category term="c语言" scheme="http://blog.lxmoses.com/tags/c%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>给博客添加Ssl</title>
    <link href="http://blog.lxmoses.com/2016/12/15/%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0ssl/"/>
    <id>http://blog.lxmoses.com/2016/12/15/给博客添加ssl/</id>
    <published>2016-12-15T13:46:38.000Z</published>
    <updated>2016-12-15T14:01:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS，也被称为HTTP over TLS，HTTP over SSL或HTTP Secure）是一种网络安全传输协议。在计算机网络上，HTTPS经由超文本传输协议进行通信，但利用SSL/TLS来对数据包进行加密。HTTPS开发的主要目的，是提供对网络服务器的身份认证，保护交换数据的隐私与完整性。<br>之前就听说过ssl，但是觉得比较鸡肋，所以开始也没准备折腾。后来看到谷歌宣布从2017年一月开始正式将http页面标记为不安全,看来这是大势所趋。<br>参照<a href="http://www.jianshu.com/p/92b6d4a6ecd5" target="_blank" rel="external">这篇博文</a>折腾了一番。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS，也被称为HTTP over TLS，HTTP over SSL或HTTP Secure）是一种网络安全传输协议。在计算机网络上，HTTPS经由超文本传输协议进行
    
    </summary>
    
      <category term="ssl" scheme="http://blog.lxmoses.com/categories/ssl/"/>
    
    
      <category term="ssl" scheme="http://blog.lxmoses.com/tags/ssl/"/>
    
  </entry>
  
  <entry>
    <title>Unix文件的时间</title>
    <link href="http://blog.lxmoses.com/2016/12/15/Unix%E6%96%87%E4%BB%B6%E7%9A%84%E6%97%B6%E9%97%B4/"/>
    <id>http://blog.lxmoses.com/2016/12/15/Unix文件的时间/</id>
    <published>2016-12-15T00:58:26.000Z</published>
    <updated>2016-12-15T01:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Unix对于每个文件维护了3个时间字段，它们的意义如下图所示：<br><img src="/images/与Unix文件相关的3个时间值.jpg" alt=""><br>很多影响到i节点的操作，如更改文件的访问权限、更改用户id、更改链接数等，但它们并没有更改文件的实际内容。因为i节点中的所有信息都是与文件的实际内容分开存放的。</p>
<p>POSIX(Portable Operating System Interface)修改文件的访问时间和修改时间<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">futimens</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">struct</span> timespec times[<span class="number">2</span>])</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">utimensat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> * path, <span class="keyword">const</span> <span class="keyword">struct</span> timespec times[<span class="number">2</span>], <span class="keyword">int</span> flag)</span></span>;</div></pre></td></tr></table></figure><br>Single UNIX Specification的XSI扩展<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">utimes</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * pathname, <span class="keyword">const</span> <span class="keyword">struct</span> timeval times[<span class="number">2</span>])</span></span>;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Unix对于每个文件维护了3个时间字段，它们的意义如下图所示：&lt;br&gt;&lt;img src=&quot;/images/与Unix文件相关的3个时间值.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;很多影响到i节点的操作，如更改文件的访问权限、更改用户id、更改链接数等，但它们并没有更改文件的实际内容
    
    </summary>
    
      <category term="重温apue" scheme="http://blog.lxmoses.com/categories/%E9%87%8D%E6%B8%A9apue/"/>
    
    
      <category term="Unix" scheme="http://blog.lxmoses.com/tags/Unix/"/>
    
      <category term="文件" scheme="http://blog.lxmoses.com/tags/%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>完美删除临时文件</title>
    <link href="http://blog.lxmoses.com/2016/12/14/%E5%AE%8C%E7%BE%8E%E5%88%A0%E9%99%A4%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6/"/>
    <id>http://blog.lxmoses.com/2016/12/14/完美删除临时文件/</id>
    <published>2016-12-14T06:38:41.000Z</published>
    <updated>2016-12-15T01:00:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者曾经写过一个爬虫，里面涉及到一些临时文件的操作。在解析页面时总会有各种各样的异常导致临时文件删除失败。如今对Unix文件系统有了一些更为深入的理解，这个问题也迎刃而解。<br>Unix文件系统中有个非常重要的概念，i节点。文件系统中的每个目录项都会指向一个i节点，每个i节点中都有一个链接计数，其值是指向该i节点的目录项数。只有当链接计数减少至0时，才可删除文件(也就是释放该文件占用的数据块).另一个条件也会阻止删除文件的内容——只要有进程打开了该文件，其内容也不会删除。<br>关闭一个文件时，内核首先检查打开该文件的进程个数；如果这个计数达到0，内核再去检查其链接计数；如果计数也是0，那么就删除该文件的内容。<br>这意味着我们可以在创建一个临时文件的时候就调用unlink函数，程序结束之后(无论是正常还是异常结束)临时文件都会被删除。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;笔者曾经写过一个爬虫，里面涉及到一些临时文件的操作。在解析页面时总会有各种各样的异常导致临时文件删除失败。如今对Unix文件系统有了一些更为深入的理解，这个问题也迎刃而解。&lt;br&gt;Unix文件系统中有个非常重要的概念，i节点。文件系统中的每个目录项都会指向一个i节点，每个i
    
    </summary>
    
      <category term="重温apue" scheme="http://blog.lxmoses.com/categories/%E9%87%8D%E6%B8%A9apue/"/>
    
    
      <category term="Unix" scheme="http://blog.lxmoses.com/tags/Unix/"/>
    
      <category term="OS" scheme="http://blog.lxmoses.com/tags/OS/"/>
    
      <category term="文件" scheme="http://blog.lxmoses.com/tags/%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>深入了解原子操作</title>
    <link href="http://blog.lxmoses.com/2016/12/14/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/"/>
    <id>http://blog.lxmoses.com/2016/12/14/深入了解原子操作/</id>
    <published>2016-12-14T04:41:46.000Z</published>
    <updated>2016-12-14T04:47:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>原子操作指的是由多步组成的一个操作。如果该操作原子地执行，则要么执行完所有步骤，要么一步也不执行，不可能只执行所有步骤的一个子集。<br>关于原子操作的概念和定义很早以前都知道了，但是对于其底层实现细节却知之不详。<br>今天看到一篇不错的文章，参见<a href="http://www.cnblogs.com/fanzhidongyzby/p/3654855.html" target="_blank" rel="external">这里</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原子操作指的是由多步组成的一个操作。如果该操作原子地执行，则要么执行完所有步骤，要么一步也不执行，不可能只执行所有步骤的一个子集。&lt;br&gt;关于原子操作的概念和定义很早以前都知道了，但是对于其底层实现细节却知之不详。&lt;br&gt;今天看到一篇不错的文章，参见&lt;a href=&quot;htt
    
    </summary>
    
      <category term="重温apue" scheme="http://blog.lxmoses.com/categories/%E9%87%8D%E6%B8%A9apue/"/>
    
    
      <category term="Unix" scheme="http://blog.lxmoses.com/tags/Unix/"/>
    
      <category term="OS" scheme="http://blog.lxmoses.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Unix内核中的文件数据结构</title>
    <link href="http://blog.lxmoses.com/2016/12/14/Unix%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://blog.lxmoses.com/2016/12/14/Unix内核中的文件数据结构/</id>
    <published>2016-12-14T03:06:54.000Z</published>
    <updated>2016-12-14T03:25:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>打开文件的内核数据结构<br><img src="/images/打开文件的内核数据结构.jpeg" alt=""><br>两个独立进程各自打开同一个文件<br><img src="/images/打开文件的内核数据结构.jpeg" alt=""><br>内核使用3种数据结构表示打开文件，它们的关系决定了在文件共享方面一个进程对另一个进程的可能产生的影响。</p>
<h2 id="进程表项"><a href="#进程表项" class="headerlink" title="进程表项"></a>进程表项</h2><p>每个进程在进程表中都有一个记录项，记录项中包含一张打开的文件描述表，可将其视为一个矢量，每个描述符占用一项。与每个文件描述符关联的是：<br>a.文件描述符标志<br>b.指向一个文件表项的指针</p>
<h2 id="文件表项"><a href="#文件表项" class="headerlink" title="文件表项"></a>文件表项</h2><p>内核为所有打开文件维持一张文件表。每个文件表项包含：<br>a.文件状态标志(读、写、添写、同步和非阻塞等)<br>b.当前文件偏移量<br>c.指向该文件v节点表项的指针</p>
<h2 id="v节点项"><a href="#v节点项" class="headerlink" title="v节点项"></a>v节点项</h2><p>每个打开文件都有一个v节点结构。v节点包含了文件类型和对此文件进行各种操作函数的指针。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;打开文件的内核数据结构&lt;br&gt;&lt;img src=&quot;/images/打开文件的内核数据结构.jpeg&quot; alt=&quot;&quot;&gt;&lt;br&gt;两个独立进程各自打开同一个文件&lt;br&gt;&lt;img src=&quot;/images/打开文件的内核数据结构.jpeg&quot; alt=&quot;&quot;&gt;&lt;br&gt;内核使用3种数据结
    
    </summary>
    
      <category term="重温apue" scheme="http://blog.lxmoses.com/categories/%E9%87%8D%E6%B8%A9apue/"/>
    
    
      <category term="Unix" scheme="http://blog.lxmoses.com/tags/Unix/"/>
    
  </entry>
  
</feed>
