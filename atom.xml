<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>悟云</title>
  <subtitle>let it be</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.lxmoses.com/"/>
  <updated>2016-12-20T01:33:53.000Z</updated>
  <id>http://blog.lxmoses.com/</id>
  
  <author>
    <name>moses</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TCP的流量控制和拥塞控制</title>
    <link href="http://blog.lxmoses.com/2016/12/20/TCP%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%92%8C%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/"/>
    <id>http://blog.lxmoses.com/2016/12/20/TCP的流量控制和拥塞控制/</id>
    <published>2016-12-20T00:19:12.000Z</published>
    <updated>2016-12-20T01:33:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h2><p>TCP的流量控制是通过滑动窗口实现的。</p>
<h3 id="什么是滑动窗口协议"><a href="#什么是滑动窗口协议" class="headerlink" title="什么是滑动窗口协议"></a>什么是滑动窗口协议</h3><p>一图胜千言，看下面的图。简单解释下，发送和接受方都会维护一个数据帧的序列，这个序列被称作窗口。发送方的窗口大小由接受方确定，目的在于控制发送速度，以免接受方的缓存不够大，而导致<br>溢出，同时控制流量也可以避免网络拥塞。下面图中的4,5,6号数据帧已经被发送出去，但是未收到关联的ACK，7,8,9帧则是等待发送。可以看出发送端的窗口大小为6，这是由接受端告知的（事实上必<br>须考虑拥塞窗口cwnd，这里暂且考虑cwnd&gt;rwnd）。此时如果发送端收到4号ACK，则窗口的左边缘向右收缩，窗口的右边缘则向右扩展，此时窗口就向前“滑动了”，即数据帧10也可以被发送。<br><img src="/images/滑动窗口.jpg" alt=""><br>下面就滑动窗口协议做出更详细的说明，这里为了简单起见设定发送方窗口大小为2，接受方大小为1。看下面图：<br><img src="/images/滑动窗口过程.gif" alt=""><br>一：初始态，发送方没有帧发出，发送窗口前后沿相重合。接收方0号窗口打开，等待接收0号帧；<br>二：发送方打开0号窗口，表示已发出0帧但尚确认返回信息。 此时接收窗口状态不变；<br>三：发送方打开0、1号窗口，表示0、1号帧均在等待确认之列。至此，发送方打开的窗口数已达规定限度，在未收到新的确认返回帧之 前，发送方将暂停发送新的数据帧。接收窗口此时状态仍未变；<br>四：接收方已收到0号帧，0号窗口关闭，1号窗口打开，表示准备接收1号帧。此时发送窗口状态不 变；<br>五：发送方收到接收方发来的0号帧确认返回信息，关闭0号窗口，表示从重发表中删除0号帧。此时接收窗口状态仍不变<br>六：发送方继续发送2号帧，2号窗口 打开，表示2号帧也纳入待确认之列。至此，发送方打开的窗口又已达规定限度，在未收到新的确认返回帧之前，发送方将暂停发送新的数据帧，此时接收窗口状态 仍不变；<br>七：接收方已收到1号帧，1号窗口关闭，2号窗口打开，表示准备接收2号帧。此时发送窗口状态不变；<br>八：发送方收到接收方发来的1号帧收毕的确认信 息，关闭1号窗口，表示从重发表中删除1号帧。此时接收窗口状态仍不变。</p>
<h3 id="1比特滑动窗口协议"><a href="#1比特滑动窗口协议" class="headerlink" title="1比特滑动窗口协议"></a>1比特滑动窗口协议</h3><p>上面说的只是滑动窗口协议的理论，实际应用中又有不同。<br>首先就是停等协议(stop－and－wait)，这时接受方的窗口和发送方的窗口大小都是1，1个比特就够表示了，所以也叫1比特滑动窗口协议。<br>发送方这时自然发送每次只能发送一个，并且必须等待这个数据包的ACK，才能发送下一个。虽然在效率上比较低，带宽利用率明显较低，不过在网络环境较差，或是带宽本身很低的情况下，还是适用的。</p>
<h3 id="后退n协议"><a href="#后退n协议" class="headerlink" title="后退n协议"></a>后退n协议</h3><p>停等协议虽然实现简单，也能较好的适用恶劣的网络环境，但是显然效率太低。所以有了后退n协议，这也是滑动窗口协议真正的用处，这里发送的窗口大小为n，接受方的窗口仍然为1。具体看下面的图，这里假设n=9：<br>首先发送方一口气发送10个数据帧，前面两个帧正确返回了，数据帧2出现了错误，这时发送方被迫重新发送2-8这7个帧，接受方也必须丢弃之前接受的3-8这几个帧。<br>后退n协议的好处无疑是提高了效率，但是一旦网络情况糟糕，则会导致大量数据重发，反而不如上面的停等协议，实际上这是很常见的，具体可以参考TCP拥塞控制。<br><img src="/images/后退n步滑动窗口.gif" alt=""></p>
<h3 id="选择重传协议"><a href="#选择重传协议" class="headerlink" title="选择重传协议"></a>选择重传协议</h3><p>后退n协议的另外一个问题是，当有错误帧出现后，总是要重发该帧之后的所有帧，毫无疑问在网络不是很好的情况下会进一步恶化网络状况，重传协议便是用来解决这个问题。<br>原理也很简单，接收端总会缓存所有收到的帧，当某个帧出现错误时，只会要求重传这一个帧，只有当某个序号后的所有帧都正确收到后，才会一起提交给高层应用。重传协议的缺点在于接受端需要更多的缓存。</p>
<h2 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h2><p>计算机网络中的带宽、交换节点中的缓存和处理机等，都是网络的资源，在某段时间内，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏，这种情况就叫做拥塞。<br>所谓拥塞控制，就是防止过多的数据注入到网络中，从而使网络中的路由器或链路不致过载。<br>要注意用拥塞控制与流量控制的区别，拥塞控制是一个全局性的过程，涉及到所有的额主机、路由器，以及与降低网<br>拥塞控制的算法有：慢开始、拥塞避免、快重传、快恢复四种。</p>
<h3 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h3><p>发送方维持一个拥塞窗口的状态变量，其大小取决于网络的拥塞程度，动态地变化，而发送窗口一般取拥塞窗口和对方给出的接收窗口的最小值（为了便于描述，后面的分析中假定对方给出的接收窗口足够大，这样将发送窗口等于拥塞窗口就可以了）。<br>慢开始算法的核心是从小到大逐渐增大发送窗口，也就是说，从小到大逐渐增大拥塞窗口的数值。通常在刚开始发送报文段时，先把拥塞窗口设置为一个最大报文段MSS的数值，而在每收到对上一轮报文段（，每次加倍后的报文段的个数，可能不止一个报文段）的确认后，就把拥塞窗口的数值加倍。<br>为了防止拥塞窗口增长过大引起网络拥塞，还需要维护一个慢开始门限的状态变量，当拥塞窗口的值小于慢开始门限时，使用慢开始算法，一旦拥塞窗口的值大于慢开始门限的值，就改用拥塞避免算法。<br>拥塞避免算法的思路是让拥塞窗口缓慢地增大，收到每一轮的确认后，将拥塞窗口的值加1，而不是加倍，这样拥塞窗口的值按照线性规律缓慢增长。<br>无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（没有按时收到确认），就把慢开始门限设置为出现拥塞时发送窗口值的一半，但最小不能小于2个MSS值，而后把拥塞窗口的值重新设置为1个MSS，执行慢开始算法。</p>
<h3 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h3><p>快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（重复发送对前面有序部分的确认），而不是等待自己发送数据时才进行稍待确认，也不是累积收到的报文发送累积确认，如果发送方连续收到三个重复确认，就应该立即重传对方未收到的报文段（有收到重复确认，说明后面的报文段都送达了，只有中间丢失的报文段没送达）。<br>快恢复算法与快重传算法配合使用，其过程有如下两个要点：<br>1、当发送方连续收到三个重复确认时，就把慢开始门限减半，这是为了预防网络发生拥塞。注意，接下来不执行慢开始算法。<br>2、由于发送方现在认为网络很很可能没有发生特别严重的阻塞（如果发生了严重阻塞的话，就不会一连有好几个报文段到达接收方，就不会导致接收方连续发送重复确认），因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口的值不设为1个MSSS），而是把拥塞窗口的值设为慢开始门限减半后的值，而后开始执行拥塞避免算法，线性地增大拥塞窗口。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;TCP的流量控制&quot;&gt;&lt;a href=&quot;#TCP的流量控制&quot; class=&quot;headerlink&quot; title=&quot;TCP的流量控制&quot;&gt;&lt;/a&gt;TCP的流量控制&lt;/h2&gt;&lt;p&gt;TCP的流量控制是通过滑动窗口实现的。&lt;/p&gt;
&lt;h3 id=&quot;什么是滑动窗口协议&quot;&gt;&lt;a 
    
    </summary>
    
      <category term="网络编程" scheme="http://blog.lxmoses.com/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="TCP" scheme="http://blog.lxmoses.com/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>闹够了</title>
    <link href="http://blog.lxmoses.com/2016/12/16/%E9%97%B9%E5%A4%9F%E4%BA%86/"/>
    <id>http://blog.lxmoses.com/2016/12/16/闹够了/</id>
    <published>2016-12-16T15:41:24.000Z</published>
    <updated>2016-12-16T15:44:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>你的城市没有一扇窗，为我打开啊。<br>我要卖掉我的房子，浪迹天涯。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你的城市没有一扇窗，为我打开啊。&lt;br&gt;我要卖掉我的房子，浪迹天涯。&lt;/p&gt;

    
    </summary>
    
      <category term="随笔" scheme="http://blog.lxmoses.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="生活" scheme="http://blog.lxmoses.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>关于C语言main函数执行前后</title>
    <link href="http://blog.lxmoses.com/2016/12/16/%E5%85%B3%E4%BA%8Ec%E8%AF%AD%E8%A8%80main%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E5%89%8D%E5%90%8E/"/>
    <id>http://blog.lxmoses.com/2016/12/16/关于c语言main函数执行前后/</id>
    <published>2016-12-16T06:07:52.000Z</published>
    <updated>2016-12-16T06:24:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前几次的面试经历中好几次面试官都问过程序运行时在main函数之前发生了些什么。 笔者大概知道是做一些初始化相关的事情，今日详细mark一下。<br>main函数执行之前，主要就是初始化系统相关资源：<br>1.设置栈指针<br>2.初始化static静态和global全局变量，即data段的内容<br>3.将未初始化部分的赋初值：数值型short，int，long等为0，bool为FALSE，指针为NULL，等等，即.bss段的内容<br>4.运行全局构造器，估计是C++中构造函数之类的吧<br>5.将main函数的参数，argc，argv等传递给main函数，然后才真正运行main函数<br>同样地，main函数结束之后就是一些资源释放的事情,以及调用之前注册的终止处理程序等等。<br>附上一段apue上注册终止程序的demo:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_exit1</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_exit2</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(atexit(my_exit2) != <span class="number">0</span>)&#123;</div><div class="line">		err_sys(<span class="string">"can't register my_exit2"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span>(atexit(my_exit1) != <span class="number">0</span>)&#123;</div><div class="line">		err_sys(<span class="string">"can't register my_exit1"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span>(atexit(my_exit1) != <span class="number">0</span>)&#123;</div><div class="line">		err_sys(<span class="string">"can't register my_exit1"</span>);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"main is done\n"</span>);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_exit1</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"first exit handler\n"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_exit2</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"second exit handler\n"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前几次的面试经历中好几次面试官都问过程序运行时在main函数之前发生了些什么。 笔者大概知道是做一些初始化相关的事情，今日详细mark一下。&lt;br&gt;main函数执行之前，主要就是初始化系统相关资源：&lt;br&gt;1.设置栈指针&lt;br&gt;2.初始化static静态和global全局
    
    </summary>
    
      <category term="重温apue" scheme="http://blog.lxmoses.com/categories/%E9%87%8D%E6%B8%A9apue/"/>
    
    
      <category term="c语言" scheme="http://blog.lxmoses.com/tags/c%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>给博客添加Ssl</title>
    <link href="http://blog.lxmoses.com/2016/12/15/%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0ssl/"/>
    <id>http://blog.lxmoses.com/2016/12/15/给博客添加ssl/</id>
    <published>2016-12-15T13:46:38.000Z</published>
    <updated>2016-12-15T14:01:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS，也被称为HTTP over TLS，HTTP over SSL或HTTP Secure）是一种网络安全传输协议。在计算机网络上，HTTPS经由超文本传输协议进行通信，但利用SSL/TLS来对数据包进行加密。HTTPS开发的主要目的，是提供对网络服务器的身份认证，保护交换数据的隐私与完整性。<br>之前就听说过ssl，但是觉得比较鸡肋，所以开始也没准备折腾。后来看到谷歌宣布从2017年一月开始正式将http页面标记为不安全,看来这是大势所趋。<br>参照<a href="http://www.jianshu.com/p/92b6d4a6ecd5" target="_blank" rel="external">这篇博文</a>折腾了一番。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS，也被称为HTTP over TLS，HTTP over SSL或HTTP Secure）是一种网络安全传输协议。在计算机网络上，HTTPS经由超文本传输协议进行
    
    </summary>
    
      <category term="ssl" scheme="http://blog.lxmoses.com/categories/ssl/"/>
    
    
      <category term="ssl" scheme="http://blog.lxmoses.com/tags/ssl/"/>
    
  </entry>
  
  <entry>
    <title>Unix文件的时间</title>
    <link href="http://blog.lxmoses.com/2016/12/15/Unix%E6%96%87%E4%BB%B6%E7%9A%84%E6%97%B6%E9%97%B4/"/>
    <id>http://blog.lxmoses.com/2016/12/15/Unix文件的时间/</id>
    <published>2016-12-15T00:58:26.000Z</published>
    <updated>2016-12-15T01:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Unix对于每个文件维护了3个时间字段，它们的意义如下图所示：<br><img src="/images/与Unix文件相关的3个时间值.jpg" alt=""><br>很多影响到i节点的操作，如更改文件的访问权限、更改用户id、更改链接数等，但它们并没有更改文件的实际内容。因为i节点中的所有信息都是与文件的实际内容分开存放的。</p>
<p>POSIX(Portable Operating System Interface)修改文件的访问时间和修改时间<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">futimens</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">struct</span> timespec times[<span class="number">2</span>])</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">utimensat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> * path, <span class="keyword">const</span> <span class="keyword">struct</span> timespec times[<span class="number">2</span>], <span class="keyword">int</span> flag)</span></span>;</div></pre></td></tr></table></figure><br>Single UNIX Specification的XSI扩展<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">utimes</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * pathname, <span class="keyword">const</span> <span class="keyword">struct</span> timeval times[<span class="number">2</span>])</span></span>;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Unix对于每个文件维护了3个时间字段，它们的意义如下图所示：&lt;br&gt;&lt;img src=&quot;/images/与Unix文件相关的3个时间值.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;很多影响到i节点的操作，如更改文件的访问权限、更改用户id、更改链接数等，但它们并没有更改文件的实际内容
    
    </summary>
    
      <category term="重温apue" scheme="http://blog.lxmoses.com/categories/%E9%87%8D%E6%B8%A9apue/"/>
    
    
      <category term="Unix" scheme="http://blog.lxmoses.com/tags/Unix/"/>
    
      <category term="文件" scheme="http://blog.lxmoses.com/tags/%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>完美删除临时文件</title>
    <link href="http://blog.lxmoses.com/2016/12/14/%E5%AE%8C%E7%BE%8E%E5%88%A0%E9%99%A4%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6/"/>
    <id>http://blog.lxmoses.com/2016/12/14/完美删除临时文件/</id>
    <published>2016-12-14T06:38:41.000Z</published>
    <updated>2016-12-15T01:00:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者曾经写过一个爬虫，里面涉及到一些临时文件的操作。在解析页面时总会有各种各样的异常导致临时文件删除失败。如今对Unix文件系统有了一些更为深入的理解，这个问题也迎刃而解。<br>Unix文件系统中有个非常重要的概念，i节点。文件系统中的每个目录项都会指向一个i节点，每个i节点中都有一个链接计数，其值是指向该i节点的目录项数。只有当链接计数减少至0时，才可删除文件(也就是释放该文件占用的数据块).另一个条件也会阻止删除文件的内容——只要有进程打开了该文件，其内容也不会删除。<br>关闭一个文件时，内核首先检查打开该文件的进程个数；如果这个计数达到0，内核再去检查其链接计数；如果计数也是0，那么就删除该文件的内容。<br>这意味着我们可以在创建一个临时文件的时候就调用unlink函数，程序结束之后(无论是正常还是异常结束)临时文件都会被删除。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;笔者曾经写过一个爬虫，里面涉及到一些临时文件的操作。在解析页面时总会有各种各样的异常导致临时文件删除失败。如今对Unix文件系统有了一些更为深入的理解，这个问题也迎刃而解。&lt;br&gt;Unix文件系统中有个非常重要的概念，i节点。文件系统中的每个目录项都会指向一个i节点，每个i
    
    </summary>
    
      <category term="重温apue" scheme="http://blog.lxmoses.com/categories/%E9%87%8D%E6%B8%A9apue/"/>
    
    
      <category term="Unix" scheme="http://blog.lxmoses.com/tags/Unix/"/>
    
      <category term="文件" scheme="http://blog.lxmoses.com/tags/%E6%96%87%E4%BB%B6/"/>
    
      <category term="OS" scheme="http://blog.lxmoses.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>深入了解原子操作</title>
    <link href="http://blog.lxmoses.com/2016/12/14/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/"/>
    <id>http://blog.lxmoses.com/2016/12/14/深入了解原子操作/</id>
    <published>2016-12-14T04:41:46.000Z</published>
    <updated>2016-12-14T04:47:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>原子操作指的是由多步组成的一个操作。如果该操作原子地执行，则要么执行完所有步骤，要么一步也不执行，不可能只执行所有步骤的一个子集。<br>关于原子操作的概念和定义很早以前都知道了，但是对于其底层实现细节却知之不详。<br>今天看到一篇不错的文章，参见<a href="http://www.cnblogs.com/fanzhidongyzby/p/3654855.html" target="_blank" rel="external">这里</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原子操作指的是由多步组成的一个操作。如果该操作原子地执行，则要么执行完所有步骤，要么一步也不执行，不可能只执行所有步骤的一个子集。&lt;br&gt;关于原子操作的概念和定义很早以前都知道了，但是对于其底层实现细节却知之不详。&lt;br&gt;今天看到一篇不错的文章，参见&lt;a href=&quot;htt
    
    </summary>
    
      <category term="重温apue" scheme="http://blog.lxmoses.com/categories/%E9%87%8D%E6%B8%A9apue/"/>
    
    
      <category term="Unix" scheme="http://blog.lxmoses.com/tags/Unix/"/>
    
      <category term="OS" scheme="http://blog.lxmoses.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Unix内核中的文件数据结构</title>
    <link href="http://blog.lxmoses.com/2016/12/14/Unix%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://blog.lxmoses.com/2016/12/14/Unix内核中的文件数据结构/</id>
    <published>2016-12-14T03:06:54.000Z</published>
    <updated>2016-12-14T03:25:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>打开文件的内核数据结构<br><img src="/images/打开文件的内核数据结构.jpeg" alt=""><br>两个独立进程各自打开同一个文件<br><img src="/images/打开文件的内核数据结构.jpeg" alt=""><br>内核使用3种数据结构表示打开文件，它们的关系决定了在文件共享方面一个进程对另一个进程的可能产生的影响。</p>
<h2 id="进程表项"><a href="#进程表项" class="headerlink" title="进程表项"></a>进程表项</h2><p>每个进程在进程表中都有一个记录项，记录项中包含一张打开的文件描述表，可将其视为一个矢量，每个描述符占用一项。与每个文件描述符关联的是：<br>a.文件描述符标志<br>b.指向一个文件表项的指针</p>
<h2 id="文件表项"><a href="#文件表项" class="headerlink" title="文件表项"></a>文件表项</h2><p>内核为所有打开文件维持一张文件表。每个文件表项包含：<br>a.文件状态标志(读、写、添写、同步和非阻塞等)<br>b.当前文件偏移量<br>c.指向该文件v节点表项的指针</p>
<h2 id="v节点项"><a href="#v节点项" class="headerlink" title="v节点项"></a>v节点项</h2><p>每个打开文件都有一个v节点结构。v节点包含了文件类型和对此文件进行各种操作函数的指针。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;打开文件的内核数据结构&lt;br&gt;&lt;img src=&quot;/images/打开文件的内核数据结构.jpeg&quot; alt=&quot;&quot;&gt;&lt;br&gt;两个独立进程各自打开同一个文件&lt;br&gt;&lt;img src=&quot;/images/打开文件的内核数据结构.jpeg&quot; alt=&quot;&quot;&gt;&lt;br&gt;内核使用3种数据结
    
    </summary>
    
      <category term="重温apue" scheme="http://blog.lxmoses.com/categories/%E9%87%8D%E6%B8%A9apue/"/>
    
    
      <category term="Unix" scheme="http://blog.lxmoses.com/tags/Unix/"/>
    
  </entry>
  
  <entry>
    <title>Unix时间值</title>
    <link href="http://blog.lxmoses.com/2016/12/14/Unix%E6%97%B6%E9%97%B4%E5%80%BC/"/>
    <id>http://blog.lxmoses.com/2016/12/14/Unix时间值/</id>
    <published>2016-12-14T01:57:19.000Z</published>
    <updated>2016-12-14T02:32:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>历史上，Unix系统使用过不同的时间值。<br>(1)日历时间。该值是自协调世界时1970年1月1日00:00:00这个特定时间以来所经过的秒数累计值。系统基本数据类型time_t用于保存这种时间值。<br>(2)进程时间。Unix系统为一个进程维护了3个进程时间值。<br>时钟时间：又称为墙上时钟时间，它是进程运行的时间总量。<br>用户cpu时间：执行用户指令所用的时间量。<br>系统cpu时间：为该进程执行内核程序所经历的时间。<br>要取得任一进程的时钟时间、用户时间和系统时间可通过执行命令time（1），其参数是要度量其执行时间的命令。例如：time ls<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">time ls</div><div class="line">Desktop   Documents Downloads Library   Movies    Music     Pictures  Public    oh-my-zsh solarized workspace</div><div class="line">ls -G  0.00s user 0.00s system 82% cpu 0.008 total</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;历史上，Unix系统使用过不同的时间值。&lt;br&gt;(1)日历时间。该值是自协调世界时1970年1月1日00:00:00这个特定时间以来所经过的秒数累计值。系统基本数据类型time_t用于保存这种时间值。&lt;br&gt;(2)进程时间。Unix系统为一个进程维护了3个进程时间值。&lt;br
    
    </summary>
    
      <category term="重温apue" scheme="http://blog.lxmoses.com/categories/%E9%87%8D%E6%B8%A9apue/"/>
    
    
      <category term="Unix" scheme="http://blog.lxmoses.com/tags/Unix/"/>
    
      <category term="OS" scheme="http://blog.lxmoses.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>文件I/O和标准I/O</title>
    <link href="http://blog.lxmoses.com/2016/12/14/%E6%96%87%E4%BB%B6I-O%E5%92%8C%E6%A0%87%E5%87%86I-O/"/>
    <id>http://blog.lxmoses.com/2016/12/14/文件I-O和标准I-O/</id>
    <published>2016-12-14T00:48:42.000Z</published>
    <updated>2016-12-14T00:59:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>标准I/O是ANSI C建立的一个标准I/O模型，是一个标准函数包和stdio.h头文件中的定义，具有一定的可移植性。标准IO库处理很多细节。例如缓存分配，以优化长度执行IO等。标准的IO提供了三种类型的缓存。<br>（1）全缓存：当填满标准IO缓存后才进行实际的IO操作。<br>（2）行缓存：当输入或输出中遇到新行符时，标准IO库执行IO操作。<br>（3）不带缓存：stderr就是了。</p>
<p>文件I/O：文件I/O称之为不带缓存的IO（unbuffered I/O)。不带缓存指的是每个read，write都调用内核中的一个系统调用。也就是一般所说的低级I/O——操作系统提供的基本IO服务，与os绑定，特定于linix或unix平台。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;标准I/O是ANSI C建立的一个标准I/O模型，是一个标准函数包和stdio.h头文件中的定义，具有一定的可移植性。标准IO库处理很多细节。例如缓存分配，以优化长度执行IO等。标准的IO提供了三种类型的缓存。&lt;br&gt;（1）全缓存：当填满标准IO缓存后才进行实际的IO操作。
    
    </summary>
    
      <category term="重温apue" scheme="http://blog.lxmoses.com/categories/%E9%87%8D%E6%B8%A9apue/"/>
    
    
      <category term="Unix" scheme="http://blog.lxmoses.com/tags/Unix/"/>
    
      <category term="IO" scheme="http://blog.lxmoses.com/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>Unix体系结构</title>
    <link href="http://blog.lxmoses.com/2016/12/14/Unix%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <id>http://blog.lxmoses.com/2016/12/14/Unix体系结构/</id>
    <published>2016-12-13T23:55:24.000Z</published>
    <updated>2016-12-14T01:00:01.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/Unix体系结构.jpg" alt=""><br>从严格意义上来说，可将操作系统定义为一种软件，它控制计算机硬件资源，提供程序运行环境。我们通常将这种软件称为内核(kernel),因为它相对较小，而且位于环境的核心。<br>内核的接口被称为系统调用(system call)。公用函数库构建在系统调用接口之上，应用程序既可使用公用函数库，也可使用系统调用。shell是一个特殊的应用程序，为运行其他程序提供了一个接口。<br>从广义上来说，操作系统包括了内核和一些其他软件，这些软件使得计算机能够发挥作用，并使计算机具有自己的特性。这里所说的其他软件包括实用程序、应用程序、shell以及公用函数库等。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/Unix体系结构.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;从严格意义上来说，可将操作系统定义为一种软件，它控制计算机硬件资源，提供程序运行环境。我们通常将这种软件称为内核(kernel),因为它相对较小，而且位于环境的核心。&lt;br&gt;内核的接口被称
    
    </summary>
    
      <category term="重温apue" scheme="http://blog.lxmoses.com/categories/%E9%87%8D%E6%B8%A9apue/"/>
    
    
      <category term="Unix" scheme="http://blog.lxmoses.com/tags/Unix/"/>
    
      <category term="OS" scheme="http://blog.lxmoses.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>再回学校</title>
    <link href="http://blog.lxmoses.com/2016/12/13/%E5%86%8D%E5%9B%9E%E5%AD%A6%E6%A0%A1/"/>
    <id>http://blog.lxmoses.com/2016/12/13/再回学校/</id>
    <published>2016-12-13T14:29:07.000Z</published>
    <updated>2016-12-13T23:58:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>这学期开学刚刚换了新工作之后，汤老师群里发来职位邀请。去了，不合适，走了。<br>今天办理完最后的离职手续，回想这份工作经历，除了工作内容不符合我的职业规划之外其他什么都好。在公司呆这么久，都是干一些打杂的内容，诸如写写脚本、购买服务器之类的。<br>辞职之后回到母校，刚开始觉得挺轻松的，终于不用早九晚九的上班了。然而，自从今年三月份出来实习之后，再也回不到那种无忧无虑打游戏的日子了。<br>仔细想想，还是好好提升下自己的技术。从明天开始，还是去图书馆打磨下自己的技术吧。<br>这条路早已没有回头路。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这学期开学刚刚换了新工作之后，汤老师群里发来职位邀请。去了，不合适，走了。&lt;br&gt;今天办理完最后的离职手续，回想这份工作经历，除了工作内容不符合我的职业规划之外其他什么都好。在公司呆这么久，都是干一些打杂的内容，诸如写写脚本、购买服务器之类的。&lt;br&gt;辞职之后回到母校，刚开
    
    </summary>
    
      <category term="随笔" scheme="http://blog.lxmoses.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://blog.lxmoses.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>再多的理智也抹不去这淡淡的愁</title>
    <link href="http://blog.lxmoses.com/2016/12/08/%E6%97%A0%E5%A5%88/"/>
    <id>http://blog.lxmoses.com/2016/12/08/无奈/</id>
    <published>2016-12-08T05:15:26.000Z</published>
    <updated>2016-12-13T23:58:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>。。。。。。。。。。。。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;。。。。。。。。。。。。。&lt;/p&gt;

    
    </summary>
    
      <category term="随笔" scheme="http://blog.lxmoses.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="生活" scheme="http://blog.lxmoses.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>失眠录（1）</title>
    <link href="http://blog.lxmoses.com/2016/12/08/%E5%A4%B1%E7%9C%A0%E5%BD%95%EF%BC%881%EF%BC%89/"/>
    <id>http://blog.lxmoses.com/2016/12/08/失眠录（1）/</id>
    <published>2016-12-07T17:34:32.000Z</published>
    <updated>2016-12-13T23:57:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天和一些朋友聊了一个有趣的话题–关于如何追女生，一位朋友提出很多攻略，另一位朋友则感叹老实人注定孤独。<br>从笔者的角度来说，更倾向于简单直接的方式，崇尚大道至简。<br>之所以会这样想笔者自我剖析有两个原因：笔者是个屌丝，不会那些套路，不想否定自己的价值；不屑或者不愿意用华丽的外表或者说套路装饰笔者认为最重要的东西。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天和一些朋友聊了一个有趣的话题–关于如何追女生，一位朋友提出很多攻略，另一位朋友则感叹老实人注定孤独。&lt;br&gt;从笔者的角度来说，更倾向于简单直接的方式，崇尚大道至简。&lt;br&gt;之所以会这样想笔者自我剖析有两个原因：笔者是个屌丝，不会那些套路，不想否定自己的价值；不屑或者不愿
    
    </summary>
    
      <category term="失眠录" scheme="http://blog.lxmoses.com/categories/%E5%A4%B1%E7%9C%A0%E5%BD%95/"/>
    
    
      <category term="随笔" scheme="http://blog.lxmoses.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>是结局也是开始</title>
    <link href="http://blog.lxmoses.com/2016/12/07/%E8%BE%9E%E8%81%8C/"/>
    <id>http://blog.lxmoses.com/2016/12/07/辞职/</id>
    <published>2016-12-07T11:37:16.000Z</published>
    <updated>2016-12-13T23:58:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前在vps上面搭了一个博客，后面服务器到期了也没管。最近比较闲，重新搭建博客，这次懒得折腾了，直接挂在github上面算了，尽管有时候会被墙。<br>说来也巧，上次的博客最后一片博文是辞职的时候写的，这次亦然。<br>回顾第一次出来实习，那时跟打了鸡血似的，想到第二天就要开始上班彻夜难眠。如今几经波折，面试了十来家公司，待了四个公司。现实总是跟理想有出入，不过除了工作以外也遇到了一些有趣的·人，经历了一些有趣的事。<br>岂能尽如人意？ 继续走，继续看，是结局也是开始。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前在vps上面搭了一个博客，后面服务器到期了也没管。最近比较闲，重新搭建博客，这次懒得折腾了，直接挂在github上面算了，尽管有时候会被墙。&lt;br&gt;说来也巧，上次的博客最后一片博文是辞职的时候写的，这次亦然。&lt;br&gt;回顾第一次出来实习，那时跟打了鸡血似的，想到第二天就要
    
    </summary>
    
      <category term="随笔" scheme="http://blog.lxmoses.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://blog.lxmoses.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
